# 跨进程通信方案

# 原生方案

| 对比项管道Pipe             | 管道Pipe                                                     | socket                                                       | AIDL                                                         | MemoryFIle | signal                         | FileObserver | UrlScheme                                          | Messenger |
| -------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ---------- | ------------------------------ | ------------ | -------------------------------------------------- | --------- |
| wiki                       | [Pipe](https://docs.oracle.com/javase/7/docs/api/java/nio/channels/Pipe.html)<br>[PipedWriter](https://developer.android.google.cn/reference/java/io/PipedWriter?hl=en)<br>[PipedReader](https://developer.android.google.cn/reference/java/io/PipedReader?hl=en) | [Socket ](https://docs.oracle.com/javase/7/docs/api/java/net/Socket.html)<br>[ServerSocket](https://docs.oracle.com/javase/7/docs/api/java/net/ServerSocket.html) |                                                              |            |                                |              |                                                    |           |
| 支持双向                   | NO                                                           | YES                                                          |                                                              |            |                                |              |                                                    |           |
| 支持本进程（多个线程）通信 | YES                                                          | YES                                                          |                                                              |            |                                |              |                                                    |           |
| 支持启动者数量(类型)       | 不限                                                         | 不限                                                         |                                                              |            |                                |              | Activity\Service\BroadcastReceiver\ContentProvider |           |
| 支持传输数据类型           |                                                              |                                                              | 基本数据类型、List、Map、String、、[Parcelable](https://developer.android.google.cn/reference/android/os/Parcelable?hl=zh_cn) |            |                                |              |                                                    |           |
| 支持事件总线               |                                                              | YES                                                          |                                                              |            |                                |              |                                                    |           |
| 支持返回结果Callback       | NO                                                           | YES                                                          | YES                                                          |            |                                |              |                                                    |           |
| 数据到达率高低             | YES                                                          | YES                                                          |                                                              |            |                                |              |                                                    |           |
| 数据最大长度               | 1024byte<br>管道流默认1024个字符                             | 65536                                                        |                                                              |            |                                |              |                                                    |           |
| 数据传输速度               |                                                              |                                                              |                                                              |            |                                |              |                                                    |           |
| 数据拷贝次数               |                                                              | 2<br>客户端拷贝一次，服务端拷贝一次                          |                                                              |            |                                |              |                                                    |           |
| 优点                       |                                                              | 支持设置超时时间                                             |                                                              |            |                                |              |                                                    |           |
| 缺点                       |                                                              | 客户端和服务端需要各自维护一个子线程监听数据传输             | 仅适合在不同App之间使用<br/>发生异常不回返回调用者<br/>必须使用Service，需要考虑兼容系统版本 |            | 不能传递复杂消息，只能用来同步 |              |                                                    |           |
| 本质                       | IO流                                                         | 传输层网络协议                                               |                                                              |            |                                |              |                                                    |           |

- AIDL仅适合：不同App通过IPC访问服务、服务中需要多线程处理
- 不跨App，建议使用Binder执行并发IPC
- 不跨App,且不存在多线程并发，建议使用Messager

# 开源方案

| 对比项               | [Andromeda](https://github.com/iqiyi/Andromeda/blob/master/CHINESE_README.md) | [Hermes\HermesEventBus](https://github.com/Xiaofei-it/HermesEventBus/blob/master/README-zh-CN.md) | [ModularizationArchitecture](https://github.com/SpinyTech/ModularizationArchitecture) | [CC](https://github.com/luckybilly/CC/wiki)                  | ActivityRouter |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------- |
| 参考wiki             | [跨进程通信框架Andromeda解析架](https://blog.csdn.net/u012165769/article/details/113006210) |                                                              |                                                              | [CC:业界首个支持渐进式组件化改造的Android组件化框架 ](https://qibilly.com/CC-website/#/) |                |
| 开源时间             | 2018年1月                                                    | 2016年6月                                                    | 2017年1月                                                    | 2017年11月                                                   |                |
| 支持双向             | YES                                                          |                                                              |                                                              |                                                              |                |
| 支持本进程通信       | YES                                                          | YES                                                          |                                                              | YES                                                          |                |
| 支持启动者数量       | Fragment\Activity                                            |                                                              |                                                              |                                                              |                |
| 支持事件总线         | YES                                                          | YES                                                          |                                                              |                                                              |                |
| 支持返回结果Callback | YES                                                          | NO                                                           |                                                              | YES                                                          |                |
| 数据到达率高低       |                                                              |                                                              |                                                              |                                                              |                |
| 数据最大长度         |                                                              |                                                              |                                                              |                                                              |                |
| 数据传输速度         |                                                              |                                                              |                                                              |                                                              |                |
| 数据拷贝次数         |                                                              |                                                              |                                                              |                                                              |                |
| 缺点                 |                                                              | 不支持oneway、in、out、inout                                 |                                                              | 仅支持开发期间                                               |                |
| 本质                 | **AIDL**                                                     | **AIDL**                                                     |                                                              | **AIDL**                                                     |                |
| 开发者               | 爱奇艺                                                       | 饿了么                                                       |                                                              |                                                              |                |

# 原生方案

## 

## Pipe

### [文档地址](https://docs.oracle.com/javase/7/docs/api/java/nio/channels/Pipe.html)

### 相关API

- `Pipe`类`open()`、`sink()`、`source()`;
- `CountDownLatch`类`countDown()`、`await()`

- `ByteBuffer`类`allocate()`、f`lip()`、`clear()`、`array()`
  
  

### Demo设计

![Pipe](http://cdn.yangchaofan.cn/typora/Pipe.png)

### Demo代码

#### **Test.java**

```java
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.Pipe;
import java.util.concurrent.CountDownLatch;

public class PipeTest {
  public static void main(String[] args) {
    try {
      CountDownLatch countDownLatch = new CountDownLatch(1);
      Pipe pipe = Pipe.open();
      Sender senderThread = new Sender(pipe, countDownLatch);
      Receiver receiverThread = new Receiver(pipe, countDownLatch);
      senderThread.start();
      receiverThread.start();
    } catch (IOException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
  }
}
```



#### **Sender.java**

```java
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.Pipe;
import java.util.concurrent.CountDownLatch;

public class Sender extends Thread {

  private Pipe pipe;
  private Pipe.SinkChannel sinkChannel;
  private CountDownLatch latch;

  public Sender(Pipe pipe, CountDownLatch latch) {
    this.pipe = pipe;
    this.sinkChannel = pipe.sink();
    this.latch = latch;
  }

  @Override
  public void run() {
    // test input content
    StringBuffer stringBuffer = new StringBuffer();
    for (int i = 0; i < 3; i++) {
      String outData = "jack：" + (i + 1) + " times good moring";
      stringBuffer.append(outData);
    }
    ByteBuffer buffer = ByteBuffer.allocate(1024);
    buffer.clear();
    buffer.put(String.valueOf(stringBuffer).getBytes());
    buffer.flip();
    try {
      while (buffer.hasRemaining()) {
        sinkChannel.write(buffer);
      }
    } catch (IOException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    } finally {
      System.out.println("senderThread send content:" + stringBuffer.toString());
      latch.countDown();
      System.out.println("senderThread send finish:");
    }
  }
}

```



#### **Receiver.java**

```java
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.Pipe;
import java.util.concurrent.CountDownLatch;

public class Receiver extends Thread {
  private Pipe pipe;
  private Pipe.SourceChannel sourceChannel;
  private CountDownLatch latch;

  public Receiver(Pipe pipe, CountDownLatch latch) {
    this.pipe = pipe;
    this.latch = latch;
    this.sourceChannel = pipe.source();
  }

  @Override
  public void run() {
    try {
      latch.await();
    } catch (InterruptedException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    ByteBuffer buffer = ByteBuffer.allocate(1024);
    int len = 0;
    StringBuffer stringBuffer = new StringBuffer();
    try {
      len = sourceChannel.read(buffer);
      buffer.flip();
      String content = new String(buffer.array(), 0, len);
      stringBuffer.append(content);
      buffer.clear();
    } catch (Exception exception) {
      exception.printStackTrace();
    } finally {
      System.out.println("ReceiverThread has receive content:" + stringBuffer);
    }

  }

}
```

## PipeReader、PipeWriter

### [文档地址](https://developer.android.google.cn/reference/java/io/PipedWriter?hl=en)

### 相关API

- `PipedWriter`类`write()`
- `PipedReade`r类`PipedWriter(PipedWriter)`、`read(buffer)`、`connect()`
- `CountDownLatch`类`countDown()`、`await()`
- `CharBuffer`类`allocate()`、f`lip()`、`clear()`、`array()`

### Demo设计

![跨进程通信调研-PipedWriter](http://cdn.yangchaofan.cn/typora/跨进程通信调研-PipedWriter.png)

### Demo代码

#### **Test.java**

```java
import java.io.IOException;
import java.io.PipedReader;
import java.io.PipedWriter;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class PipedReaderTest {
  public static void main(String[] args) {
    try {
      CountDownLatch countDownLatch = new CountDownLatch(1);
      PipedWriter pipedWriter = new PipedWriter();
      PipedReader pipedReader = new PipedReader(pipedWriter);
      Sender sender = new Sender(pipedWriter,countDownLatch);
      Receiver receiver = new Receiver(pipedReader, pipedWriter,countDownLatch);
      ExecutorService service = Executors.newCachedThreadPool();
      service.execute(sender);
      service.execute(receiver);
    } catch (IOException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
  }

}
```



#### **Sender.java**

```java
import java.io.IOException;
import java.io.PipedWriter;
import java.util.concurrent.CountDownLatch;

public class Sender implements Runnable {
  PipedWriter pipedWriter;
  CountDownLatch latch;

  public Sender(PipedWriter pipedWriter, CountDownLatch latch) {
    this.pipedWriter = pipedWriter;
    this.latch = latch;
  }

  @Override
  public void run() {
    try {
      // TODO Auto-generated method stub
      StringBuffer stringBuffer = new StringBuffer();
      for (char a = 'a'; a <= 'z'; a++) {
        stringBuffer.append(a);
      }
      pipedWriter.write(stringBuffer.toString().toCharArray(), 0, stringBuffer.length());
      System.out.println("sedner content :"+stringBuffer);
    } catch (IOException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    } finally {
      latch.countDown();
      System.out.println("sedner has finish");
    }
  }
}
```

#### **Receiver.java**

```java
import java.io.IOException;
import java.io.PipedReader;
import java.io.PipedWriter;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.util.concurrent.CountDownLatch;

public class Receiver implements Runnable {
  private PipedWriter pipedWriter;
  private PipedReader pipedReader;
  private CountDownLatch latch;

  public Receiver(PipedReader pipedReader, PipedWriter pipedWriter, CountDownLatch latch) {
    this.pipedReader = pipedReader;
    this.pipedWriter = pipedWriter;
    this.latch = latch;
  }

  @Override
  public void run() {
    try {
      latch.await();
      StringBuffer stringBuffer = new StringBuffer();
      CharBuffer buffer = CharBuffer.allocate(1024);
      int len =  pipedReader.read(buffer);
      buffer.flip();
      String a = new String(buffer.array(),0,len);
      stringBuffer.append(a);
      buffer.clear();
      System.out.println("receiver content:" + stringBuffer);
    } catch (IOException | InterruptedException e) {
      e.printStackTrace();
    } finally {
      System.out.print("receiver has finish");
    }
  }

}
```


## Socket

### [文档地址](https://docs.oracle.com/javase/7/docs/api/java/net/Socket.html)

### 相关API

- `ServerSocket`类：`accept() `
- `Socket`类：`getInputStream()` 、`getOutputStream()`
- `PrintStream`类：`println()`
- `BufferedReader`类：`readLine()`
- `System`类：`System.in`
- Collections

### Demo设计

![跨进程通信调研-Socket](http://cdn.yangchaofan.cn/typora/跨进程通信调研-Socket.png)

### Demo代码

#### **MySever.java**

```java
import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class MySever {
    public static List<Socket> socketList = Collections.synchronizedList(new ArrayList<>());

    public static void main(String[] args) {
        try {
            ServerSocket serverSocket = new ServerSocket(10086);
            System.out.println("服务器启动");
            int count = 0;
            while (true) {
                Socket s = serverSocket.accept();
                System.out.println("识别到新用户进入:");
                count++;
                socketList.add(s);
                new Thread(new ServerThread(s)).start();
                System.out.println("client enter chat home successful!");
                System.out.println("chat room has"+count+" users");
            }
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }
}
```



#### **ServerThread.java**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.net.InetAddress;
import java.net.Socket;

public class ServerThread implements Runnable {
    Socket Socket;
    BufferedReader br = null;

    public ServerThread(Socket socket) {
        this.Socket = socket;
        try {
            this.br = new BufferedReader(new InputStreamReader(socket.getInputStream()));
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    @Override
    public void run() {
        // TODO Auto-generated method stub
        String conent = null;
        while ((conent = readFromClient()) != null) {
            for (Socket s : MySever.socketList) {
                PrintStream printStream;
                try {
                    printStream = new PrintStream(s.getOutputStream());
                    // client message print
                    System.out.println("server receive message:" + conent);
                    InetAddress inetAddress = s.getInetAddress();
                    StringBuffer stringReply = new StringBuffer();
                    stringReply.append("{'to_client':{");
                    stringReply.append("client_ip:" + inetAddress.getHostAddress() + ",");
                    stringReply.append("server_message:" + "服务器很好，勿念");
                    stringReply.append("}}");
                    // response message to client
                    printStream.println("server say:" + stringReply + " ,by");
                } catch (IOException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
        }
    }

    private String readFromClient() {
        try {
            return br.readLine();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
            MySever.socketList.remove(Socket);
        }
        return null;
    }

}
```



#### **MyClient.java**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.net.Socket;
import java.net.UnknownHostException;

public class MyClient {
    public static void main(String[] args) throws UnknownHostException, IOException {
        Socket socket = new Socket("127.0.0.1", 10086);
        new Thread(new ClientThread(socket)).start();
        PrintStream printStream = new PrintStream(socket.getOutputStream());
        String line = null;
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
        while ((line = bufferedReader.readLine()) != null) {
            printStream.println(line);
      }
    }
}
```

#### **ClientThread.java**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.Socket;

public class ClientThread implements Runnable {
    Socket socket;
    BufferedReader bufferedReader = null;

    public ClientThread(Socket socket) {
        this.socket = socket;
        try {
            bufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream()));
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    @Override
    public void run() {
        // TODO Auto-generated method stub
        String conent = null;
        try {
            while ((conent = bufferedReader.readLine()) != null) {
                System.out.println(conent);
            }
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }
}
```



## AIDL

### [文档地址](https://developer.android.google.cn/guide/components/aidl?hl=zh_cn)

### 相关API

- `Service`类：`onBind() `
- `IRemoteService`类：`setUser()`、` isLogin()`、`asInterface()`
- `IRemoteService.Stub`类：`setUser()`、` isLogin()`、`asInterface()`
- `SharedPreferences`类：`putString`、`commit`、`apply`、`SharedPreferences.Editor`
- `ServiceConnection`类：`onServiceConnected()`、` onServiceDisconnected()`
- `Activity`类:`bindService()`

### Demo设计

![AIDLdemo类图](http://cdn.yangchaofan.cn/typora/AIDLdemo类图.jpg)

### Demo代码-基本数据类型

#### **IRemoteService.aidl**

1.位于`src\main\aidl\com\shaunsheep\aidlclient\IRemoteService.aidl`下

2.build/rebuild的时候会生成Java版本的IRemoteService接口,输出结果位于`build\generated\aidl_source_output_dir\debug\compileDebugAidl\out\com\shaunsheep\aidlclient\IRemoteService.java`

```java
// IRemoteService.aidl
package com.shaunsheep.aidlclient;

// Declare any non-default types here with import statements
interface IRemoteService {

    /**
     * Demonstrates some basic types that you can use as parameters
     * and return values in AIDL.
     */
    void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,
            double aDouble, String aString);
    void setUser(String userName,String passWord);
    boolean isLogin();
}
```



#### **服务端RemoteService.java**

1.提供一个内部类IRemoteService.Stub mBinder

2.让客户端App调用，会返回给客户端App这个mBinder对象，通过mBinder对象，客户端可以生成IRemoteService的实现类。有了这个实现类，客户端App就可以IPC通信，调用RemoteService下的mBinder方法，获取登录状态，设置登录信息

3.让服务端App调用onServiceConnected，可以获取到mBinder，进而可以IPC通信，调用mBinder的方法，获取登录状态、设置登录信息

```java
package com.shaunsheep.server;

import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.os.IBinder;
import android.os.RemoteException;
import android.text.TextUtils;
import android.util.Log;

import com.shaunsheep.aidlclient.IRemoteService;

/**
 * @author
 */
public class RemoteService extends Service {
    private static final String SP_USERNAME_ = "userName";
    private static final String SP_PASSWORD_ = "password";
    private static final String SP_FILE_NAME = "accountdb";
    private  SharedPreferences mPreferences;
    private  SharedPreferences.Editor mEdit;

    public RemoteService() {

    }

    @Override
    public void onCreate() {
        super.onCreate();
        mPreferences = getSharedPreferences(SP_FILE_NAME, Context.MODE_PRIVATE);
        mEdit = mPreferences.edit();
    }

    @Override
    public IBinder onBind(Intent intent) {
        // return stub implementation
        return mBinder;
    }

    private final IRemoteService.Stub mBinder = new IRemoteService.Stub() {
        @Override
        public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) throws RemoteException {

        }

        @Override
        public void setUser(String userName, String passWord) throws RemoteException {
            mEdit.putString(SP_USERNAME_,userName);
            mEdit.putString(SP_PASSWORD_,passWord);
            mEdit.commit();
            Log.d("shaunsheep","setUser!!!");
        }

        @Override
        public boolean isLogin() throws RemoteException {
            String userName = mPreferences.getString(SP_USERNAME_,"");
            String password = mPreferences.getString(SP_PASSWORD_,"");
            Log.d("shaunsheep","isLogin!!!");
            if (TextUtils.isEmpty(userName) || TextUtils.isEmpty(password)) {
                return false;
            }
            return true;
        }

    };

}
```

记得在服务端清单文件注册该服务

```java
<service
            android:name=".RemoteService"
            android:enabled="true"
            android:exported="true">
            <intent-filter>
                <action android:name="com.shaunsheep.IRemoteService" />
            </intent-filter>
 </service>
```



#### **服务端MainActivity**

```java
package com.shaunsheep.server;

import android.content.ComponentName;
import android.content.Intent;
import android.content.ServiceConnection;
import android.os.Bundle;
import android.os.IBinder;
import android.os.RemoteException;
import android.view.View;
import android.widget.TextView;

import androidx.appcompat.app.AppCompatActivity;

import com.shaunsheep.aidlclient.IRemoteService;

public class MainActivity extends AppCompatActivity {
    private IRemoteService.Stub mBinder;

    /**
     * 获取app的信息显示到server上
     */
    private ServiceConnection serviceConnection = new ServiceConnection() {
        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            mBinder = (IRemoteService.Stub) service;
            changeStatus();
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {

        }
    };
    private TextView mTextView;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Intent intent = new Intent(MainActivity.this, RemoteService.class);
        bindService(intent, serviceConnection, BIND_AUTO_CREATE);
        mTextView = findViewById(R.id.tv_data);
    }

    @Override
    protected void onResume() {
        super.onResume();
        changeStatus();
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        unbindService(serviceConnection);
        mBinder = null;
    }

    public void changeStatus() {
        try {
            if (mBinder == null) {
                return;
            }
            if (mBinder.isLogin()) {
                mTextView.setText("已登录");
            } else {
                mTextView.setText("未登录");
            }
        } catch (RemoteException e) {
            e.printStackTrace();
        }

    }

    public void logout(View view) {
        try {
            mBinder.setUser("", "");
            changeStatus();
        } catch (RemoteException e) {
            e.printStackTrace();
        }

    }

    public void login(View view) {
        try {
            mBinder.setUser("jack123", "123");
            changeStatus();
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }
}
```

#### **客户端MainActivity**

1.启动服务端App的`Service`，绑定`ServiceConnection`链接

2.从`ServiceConnection`中拿到服务端`Service`的内部类`IBinder`子类

3.通过`IRemoteService.Stub.asInterface(ibinder)`将`ibinder`子类转为`IRemoteService实现类`

4.在客户端App任何位置都可以通过操作`IRemoteService实现类`，来达到访问服务端App的效果

```java
package com.shaunsheep.aidlclient;

import android.content.ComponentName;
import android.content.Intent;
import android.content.ServiceConnection;
import android.os.Bundle;
import android.os.IBinder;
import android.os.RemoteException;
import android.view.View;
import android.widget.TextView;

import androidx.appcompat.app.AppCompatActivity;

public class MainActivity extends AppCompatActivity {
    private IRemoteService mRemoteService;
    private ServiceConnection mServerConnection = new ServiceConnection() {
        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            mRemoteService = IRemoteService.Stub.asInterface(service);
            if (mRemoteService != null) {
                try {
                    boolean isLogin = mRemoteService.isLogin();
                    changeLoginState(isLogin);
                } catch (RemoteException e) {
                    e.printStackTrace();
                }
            }
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {
            mRemoteService = null;
        }
    };
    private TextView mTvTest;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        mTvTest = findViewById(R.id.tv_test);

        Intent intent = new Intent(IRemoteService.class.getName());
        intent.setPackage("com.shaunsheep.server");
        intent.setAction("com.shaunsheep.IRemoteService");
        bindService(intent, mServerConnection, BIND_AUTO_CREATE);
    }

    public void login(View view) {
        if (mRemoteService != null) {
            try {
                mRemoteService.setUser("shaunshepp", "123123");
                boolean isLogin = mRemoteService.isLogin();
                changeLoginState(isLogin);
            } catch (RemoteException e) {
                e.printStackTrace();
            }
        }
    }

    public void changeLoginState(boolean isLogin) {
        if (isLogin) {
            mTvTest.setText("已登录");
        } else {
            mTvTest.setText("未登录");
        }
    }

    @Override
    protected void onResume() {
        super.onResume();
        try {
            if (mRemoteService == null) {
                return;
            }
            changeLoginState(mRemoteService.isLogin());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        unbindService(mServerConnection);
    }

    public void logout(View view) {
        if (mRemoteService != null) {
            try {
                mRemoteService.setUser("", "");
                boolean isLogin = mRemoteService.isLogin();
                changeLoginState(isLogin);

            } catch (RemoteException e) {
                e.printStackTrace();
            }
        }

    }
}
```

### Demo代码-自定义数据类型

我们假设提供一个User对象，供客户端和服务端通信使用

它有如下步骤；

在服务端进行如下步骤：

1. 在src/main/aidl目录下创建User.java，继承Parcelable接口，实现必要的方法
2. 在src/main/aidl目录下创建User.aidl，声明User.java可以被引用
3. 在src/main/aidl/IRemoteService里import 导入User，提供User的设置和访问接口

在客户端进行如下步骤：

1. 在src/main/aidl目录下创建User.java，继承Parcelable接口，实现必要的方法
2. 在src/main/aidl目录下创建User.aidl，声明User.java可以被引用
3. 在src/main/aidl/IRemoteService里import 导入User，提供User的设置和访问接口

- [与Service实现双向通信（三） (race604.com)](https://www.race604.com/communicate-with-remote-service-3/)

!>注意事项

1.客户端和服务端的aidl包名必须一致

2.传输自定义数据类型的时候，注意in、out、inout的使用

 in 表示数据只能由客户端流向服务端

 out 表示数据只能由服务端流向客户端，

 inout 则表示数据可在服务端与客户端之间双向流通。

其中，数据流向是针对在客户端中的那个传入方法的对象而言的。

in 为定向 tag 的话表现为服务端将会接收到一个那个对象的完整数据，但是客户端的那个对象不会因为服务端对传参的修改而发生变动；

out 的话表现为服务端将会接收到那个对象的参数为空的对象，但是在服务端对接收到的空对象有任何修改之后客户端将会同步变动；

inout 为定向 tag 的情况下，服务端将会接收到客户端传来对象的完整信息，并且客户端将会同步服务端对该对象的任何变动

#### IRemoteService.java

文件位置：

服务端`app-server/src/main/aidl/com/shaunsheep/server/IRemoteService.aidl`

`客户端`app/src/main/aidl/com/shaunsheep/server/IRemoteService.aidl`

比前一个demo相比，多了setUserObject接口和getUser接口

```java
// IRemoteService.aidl
// 客户端服务端包名一致
package com.shaunsheep.server;

// Declare any non-default types here with import statements
import com.shaunsheep.server.User;
interface IRemoteService {

    /**
     * Demonstrates some basic types that you can use as parameters
     * and return values in AIDL.
     */
    void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,
              double aDouble, String aString);

      void setUser(String userName,String passWord);
      void setUserObject(in User user);
      boolean isLogin();
      User getUser();
}
```

#### User.aidl

文件位置：

服务端`app-server/src/main/aidl/com/shaunsheep/server/User.aidl`

客户端`app/src/main/aidl/com/shaunsheep/server/User.aidl`

```java
// User.aidl
package com.shaunsheep.server;
// Declare any non-default types here with import statements
parcelable User;
```



#### User.java

文件位置：

服务端`app-server/src/main/aidl/com/shaunsheep/server/User.java`

客户端`app/src/main/aidl/com/shaunsheep/server/User.java`

```java
package com.shaunsheep.server;

import android.os.Parcel;
import android.os.Parcelable;

public final class User implements Parcelable {
    public int left;
    public int top;
    public int right;
    public int bottom;
    public String userName;
    public String passWord;

    public static final Parcelable.Creator<User> CREATOR = new Parcelable.Creator<User>() {
        @Override
        public User createFromParcel(Parcel in) {
            return new User(in);
        }

        @Override
        public User[] newArray(int size) {
            return new User[size];
        }
    };

    public User() {
    }

    private User(Parcel in) {
        readFromParcel(in);
    }

    @Override
    public void writeToParcel(Parcel out, int flags) {
        out.writeInt(left);
        out.writeInt(top);
        out.writeInt(right);
        out.writeInt(bottom);
        out.writeString(userName);
        out.writeString(passWord);

    }

    public void readFromParcel(Parcel in) {
        left = in.readInt();
        top = in.readInt();
        right = in.readInt();
        bottom = in.readInt();
        userName = in.readString();
        passWord = in.readString();
    }

    public int describeContents() {
        return 0;
    }
}
```



#### 服务端RemoteService.java

比上一个demo相比，内部类mBinder多了俩对外暴露的接口`setUserObject`、`getUser`，需要实现一下，供客户端和服务端调用

```java
package com.shaunsheep.server;

import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.os.IBinder;
import android.os.RemoteException;
import android.text.TextUtils;
import android.util.Log;


/**
 * @author
 */
public class RemoteService extends Service {
    private static final String SP_USERNAME_ = "userName";
    private static final String SP_PASSWORD_ = "password";
    private static final String SP_FILE_NAME = "accountdb";
    private SharedPreferences mPreferences;
    private SharedPreferences.Editor mEdit;

    public RemoteService() {

    }

    @Override
    public void onCreate() {
        super.onCreate();
        mPreferences = getSharedPreferences(SP_FILE_NAME, Context.MODE_PRIVATE);
        mEdit = mPreferences.edit();
    }

    @Override
    public IBinder onBind(Intent intent) {
        // return stub implementation
        return mBinder;
    }

    private final IRemoteService.Stub mBinder = new IRemoteService.Stub() {
        @Override
        public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) throws RemoteException {

        }

        @Override
        public void setUser(String userName, String passWord) throws RemoteException {
            mEdit.putString(SP_USERNAME_, userName);
            mEdit.putString(SP_PASSWORD_, passWord);
            mEdit.commit();
            Log.d("shaunsheep", "setUser!!!");
        }

        @Override
        public boolean isLogin() throws RemoteException {
            String userName = mPreferences.getString(SP_USERNAME_, "");
            String password = mPreferences.getString(SP_PASSWORD_, "");
            Log.d("shaunsheep", "isLogin!!!");
            if (TextUtils.isEmpty(userName) || TextUtils.isEmpty(password)) {
                return false;
            }
            return true;
        }

        @Override
        public void setUserObject(User user) throws RemoteException {
            if (user == null) {
                return;
            }
            mEdit.putString(SP_USERNAME_, user.userName);
            mEdit.putString(SP_PASSWORD_, user.passWord);
            mEdit.commit();
        }

        @Override
        public User getUser() throws RemoteException {
            String userName = mPreferences.getString(SP_USERNAME_, "");
            String password = mPreferences.getString(SP_PASSWORD_, "");
            User user = new User();
            user.userName = userName;
            user.passWord = password;
            return user;
        }
    };

}
```

#### 客户端MainActivity

调用获取服务端的getUser接口数据，显示到UI上；设置User对象，传递给服务端

```java
    public void getUser(View view) {
        try {
            User user = mRemoteService.getUser();
            mTvUserData.setText("{" + user.userName + ":" + user.passWord + "}");
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    public void setUserObject(View view) {
        try {
            User user = new User();
            user.passWord = "jack";
            user.userName = "jack";
            mRemoteService.setUserObject(user);
            mTvUserData.setText("{" + user.userName + ":" + user.passWord + "}");
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }
```



#### 服务端MainActivity

# 线程通信方案

- 全局变量

- Handler

- Semaphore

- countDownLatch

- 管道

- ThreadLocal

- EventBus

  

#### 

# 问题集合

## Service Intent must be explicit: Intent 

- 使用隐式意图的话，加上包名信息即可；

```java
Intent intent = new Intent();  
intent.setAction("com.yulore.recognize.android");  
intent.setPackage(context.getPackageName());    //兼容Android 5.0  
context.startService(intent);  
```

- 显示意图

```java
Intent intent = new Intent(com.yulore.test.AppService.class);  
context.startService(intent);  
```

