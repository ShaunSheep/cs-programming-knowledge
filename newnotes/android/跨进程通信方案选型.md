# 跨进程通信方案

# 原生方案

| 对比项管道Pipe             | 管道Pipe                                                     | socket                                           | binder | AIDL | MemoryFIle | signal                         | FileObserver | UrlScheme                                          | Messenger |
| -------------------------- | ------------------------------------------------------------ | ------------------------------------------------ | ------ | ---- | ---------- | ------------------------------ | ------------ | -------------------------------------------------- | --------- |
| wiki                       | [Pipe](https://docs.oracle.com/javase/7/docs/api/java/nio/channels/Pipe.html)<br>[PipedWriter](https://developer.android.google.cn/reference/java/io/PipedWriter?hl=en)<br>[PipedReader](https://developer.android.google.cn/reference/java/io/PipedReader?hl=en) |                                                  |        |      |            |                                |              |                                                    |           |
| 支持双向                   | NO                                                           | YES                                              |        |      |            |                                |              |                                                    |           |
| 支持本进程（多个线程）通信 | YES                                                          | YES                                              |        |      |            |                                |              |                                                    |           |
| 支持启动者数量(类型)       |                                                              |                                                  |        |      |            |                                |              | Activity\Service\BroadcastReceiver\ContentProvider |           |
| 支持事件总线               |                                                              | YES                                              |        |      |            |                                |              |                                                    |           |
| 支持返回结果Callback       | NO                                                           | YES                                              |        |      |            |                                |              |                                                    |           |
| 数据到达率高低             | YES                                                          | YES                                              |        |      |            |                                |              |                                                    |           |
| 数据最大长度               | 1024byte<br>管道流默认1024个字符                             |                                                  |        |      |            |                                |              |                                                    |           |
| 数据传输速度               |                                                              |                                                  |        |      |            |                                |              |                                                    |           |
| 数据拷贝次数               |                                                              | 2<br>客户端拷贝一次，服务端拷贝一次              |        |      |            |                                |              |                                                    |           |
| 缺点                       |                                                              | 客户端和服务端需要各自维护一个子线程监听数据传输 |        |      |            | 不能传递复杂消息，只能用来同步 |              |                                                    |           |
| 本质                       | IO流                                                         | 传输层网络协议                                   |        |      |            |                                |              |                                                    |           |

# 开源方案

| 对比项               | [Andromeda](https://github.com/iqiyi/Andromeda/blob/master/CHINESE_README.md) | [Hermes\HermesEventBus](https://github.com/Xiaofei-it/HermesEventBus/blob/master/README-zh-CN.md) | [ModularizationArchitecture](https://github.com/SpinyTech/ModularizationArchitecture) | [CC](https://github.com/luckybilly/CC/wiki)                  | ActivityRouter |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------- |
| 参考wiki             | [跨进程通信框架Andromeda解析架](https://blog.csdn.net/u012165769/article/details/113006210) |                                                              |                                                              | [CC:业界首个支持渐进式组件化改造的Android组件化框架 ](https://qibilly.com/CC-website/#/) |                |
| 开源时间             | 2018年1月                                                    | 2016年6月                                                    | 2017年1月                                                    | 2017年11月                                                   |                |
| 支持双向             | YES                                                          |                                                              |                                                              |                                                              |                |
| 支持本进程通信       | YES                                                          | YES                                                          |                                                              | YES                                                          |                |
| 支持启动者数量       | Fragment\Activity                                            |                                                              |                                                              |                                                              |                |
| 支持事件总线         | YES                                                          | YES                                                          |                                                              |                                                              |                |
| 支持返回结果Callback | YES                                                          | NO                                                           |                                                              | YES                                                          |                |
| 数据到达率高低       |                                                              |                                                              |                                                              |                                                              |                |
| 数据最大长度         |                                                              |                                                              |                                                              |                                                              |                |
| 数据传输速度         |                                                              |                                                              |                                                              |                                                              |                |
| 数据拷贝次数         |                                                              |                                                              |                                                              |                                                              |                |
| 缺点                 |                                                              | 不支持oneway、in、out、inout                                 |                                                              | 仅支持开发期间                                               |                |
| 本质                 | **AIDL**                                                     | **AIDL**                                                     |                                                              | **AIDL**                                                     |                |
| 开发者               | 爱奇艺                                                       | 饿了么                                                       |                                                              |                                                              |                |

# 原生方案

## 管道

### Pipe

- #### [文档地址](https://docs.oracle.com/javase/7/docs/api/java/nio/channels/Pipe.html)

- #### 相关API：
  
  - `Pipe`类`open()`、`sink()`、`source()`;
  - `CountDownLatch`类`countDown()`、`await()`
- `ByteBuffer`类`allocate()`、f`lip()`、`clear()`、`array()`
  
- #### Demo设计

  ![Pipe](http://cdn.yangchaofan.cn/typora/Pipe.png)

- #### Demo代码

  **Test.java**

  ```java
  import java.io.IOException;
  import java.nio.ByteBuffer;
  import java.nio.channels.Pipe;
  import java.util.concurrent.CountDownLatch;
  
  public class PipeTest {
    public static void main(String[] args) {
      try {
        CountDownLatch countDownLatch = new CountDownLatch(1);
        Pipe pipe = Pipe.open();
        Sender senderThread = new Sender(pipe, countDownLatch);
        Receiver receiverThread = new Receiver(pipe, countDownLatch);
        senderThread.start();
        receiverThread.start();
      } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
      }
    }
  }
  ```

  

  **Sender.java**

  ```java
  import java.io.IOException;
  import java.nio.ByteBuffer;
  import java.nio.channels.Pipe;
  import java.util.concurrent.CountDownLatch;
  
  public class Sender extends Thread {
  
    private Pipe pipe;
    private Pipe.SinkChannel sinkChannel;
    private CountDownLatch latch;
  
    public Sender(Pipe pipe, CountDownLatch latch) {
      this.pipe = pipe;
      this.sinkChannel = pipe.sink();
      this.latch = latch;
    }
  
    @Override
    public void run() {
      // test input content
      StringBuffer stringBuffer = new StringBuffer();
      for (int i = 0; i < 3; i++) {
        String outData = "jack：" + (i + 1) + " times good moring";
        stringBuffer.append(outData);
      }
      ByteBuffer buffer = ByteBuffer.allocate(1024);
      buffer.clear();
      buffer.put(String.valueOf(stringBuffer).getBytes());
      buffer.flip();
      try {
        while (buffer.hasRemaining()) {
          sinkChannel.write(buffer);
        }
      } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
      } finally {
        System.out.println("senderThread send content:" + stringBuffer.toString());
        latch.countDown();
        System.out.println("senderThread send finish:");
      }
    }
  }
  
  ```

  

  **Receiver.java**

  ```java
  import java.io.IOException;
  import java.nio.ByteBuffer;
  import java.nio.channels.Pipe;
  import java.util.concurrent.CountDownLatch;
  
  public class Receiver extends Thread {
    private Pipe pipe;
    private Pipe.SourceChannel sourceChannel;
    private CountDownLatch latch;
  
    public Receiver(Pipe pipe, CountDownLatch latch) {
      this.pipe = pipe;
      this.latch = latch;
      this.sourceChannel = pipe.source();
    }
  
    @Override
    public void run() {
      try {
        latch.await();
      } catch (InterruptedException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
      }
      ByteBuffer buffer = ByteBuffer.allocate(1024);
      int len = 0;
      StringBuffer stringBuffer = new StringBuffer();
      try {
        len = sourceChannel.read(buffer);
        buffer.flip();
        String content = new String(buffer.array(), 0, len);
        stringBuffer.append(content);
        buffer.clear();
      } catch (Exception exception) {
        exception.printStackTrace();
      } finally {
        System.out.println("ReceiverThread has receive content:" + stringBuffer);
      }
  
    }
  
  }
  ```

### PipeReader、PipeWriter

- #### [文档地址](https://developer.android.google.cn/reference/java/io/PipedWriter?hl=en)

- #### 相关API
  
  - `PipedWriter`类`write()`
  - `PipedReade`r类`PipedWriter(PipedWriter)`、`read(buffer)`、`connect()`
  - `CountDownLatch`类`countDown()`、`await()`
  - `CharBuffer`类`allocate()`、f`lip()`、`clear()`、`array()`
- #### Demo设计

![跨进程通信调研-PipedWriter](http://cdn.yangchaofan.cn/typora/跨进程通信调研-PipedWriter.png)

- #### Demo代码

  **Test.java**

  ```java
  import java.io.IOException;
  import java.io.PipedReader;
  import java.io.PipedWriter;
  import java.util.concurrent.CountDownLatch;
  import java.util.concurrent.ExecutorService;
  import java.util.concurrent.Executors;
  
  public class PipedReaderTest {
    public static void main(String[] args) {
      try {
        CountDownLatch countDownLatch = new CountDownLatch(1);
        PipedWriter pipedWriter = new PipedWriter();
        PipedReader pipedReader = new PipedReader(pipedWriter);
        Sender sender = new Sender(pipedWriter,countDownLatch);
        Receiver receiver = new Receiver(pipedReader, pipedWriter,countDownLatch);
        ExecutorService service = Executors.newCachedThreadPool();
        service.execute(sender);
        service.execute(receiver);
      } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
      }
    }
  
  }
  ```

  

  **Sender.java**

  ```java
  import java.io.IOException;
  import java.io.PipedWriter;
  import java.util.concurrent.CountDownLatch;
  
  public class Sender implements Runnable {
    PipedWriter pipedWriter;
    CountDownLatch latch;
  
    public Sender(PipedWriter pipedWriter, CountDownLatch latch) {
      this.pipedWriter = pipedWriter;
      this.latch = latch;
    }
  
    @Override
    public void run() {
      try {
        // TODO Auto-generated method stub
        StringBuffer stringBuffer = new StringBuffer();
        for (char a = 'a'; a <= 'z'; a++) {
          stringBuffer.append(a);
        }
        pipedWriter.write(stringBuffer.toString().toCharArray(), 0, stringBuffer.length());
        System.out.println("sedner content :"+stringBuffer);
      } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
      } finally {
        latch.countDown();
        System.out.println("sedner has finish");
      }
    }
  }
  ```

  **Receiver.java**

  ```java
  import java.io.IOException;
  import java.io.PipedReader;
  import java.io.PipedWriter;
  import java.nio.ByteBuffer;
  import java.nio.CharBuffer;
  import java.util.concurrent.CountDownLatch;
  
  public class Receiver implements Runnable {
    private PipedWriter pipedWriter;
    private PipedReader pipedReader;
    private CountDownLatch latch;
  
    public Receiver(PipedReader pipedReader, PipedWriter pipedWriter, CountDownLatch latch) {
      this.pipedReader = pipedReader;
      this.pipedWriter = pipedWriter;
      this.latch = latch;
    }
  
    @Override
    public void run() {
      try {
        latch.await();
        StringBuffer stringBuffer = new StringBuffer();
        CharBuffer buffer = CharBuffer.allocate(1024);
        int len =  pipedReader.read(buffer);
        buffer.flip();
        String a = new String(buffer.array(),0,len);
        stringBuffer.append(a);
        buffer.clear();
        System.out.println("receiver content:" + stringBuffer);
      } catch (IOException | InterruptedException e) {
        e.printStackTrace();
      } finally {
        System.out.print("receiver has finish");
      }
    }
  
  }
  ```


## Socket

[Java使用多线程实现Socket多客户端的通信 - 横横竖横 - 博客园 (cnblogs.com)](https://www.cnblogs.com/aibaofeng/p/10139005.html)

- 文档地址

- Demo设计

  

- Demo代码

  **SocketTest.java**

  ```java
  import java.io.IOException;
  import java.net.InetAddress;
  import java.net.ServerSocket;
  import java.net.Socket;
  
  public class SocketTest {
    public static void main(String[] args) {
      try {
        ServerSocket serverSocket = new ServerSocket(10086);
        // client socket
        Socket socket = null;
        // client numbers
        int count = 0;
        System.out.println("服务器启动");
        while (true) {
          // detect client connection
          socket = serverSocket.accept();
          System.out.println("detect client enter chat home!");
          // get client connection
          InetAddress inetAddress = socket.getInetAddress();
          SocketServerThread socketServerThread = new SocketServerThread(socket, inetAddress);
          socketServerThread.start();
  
          count++;
          System.out.println("client enter chat home successful!");
          System.out.println("chat room has "+count+" users");
        }
      } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
      }
    }
  
  }
  ```

  

  **ServerThread.java**

  ```java
  import java.io.BufferedReader;
  import java.io.IOException;
  import java.io.InputStream;
  import java.io.InputStreamReader;
  import java.io.OutputStream;
  import java.io.OutputStreamWriter;
  import java.net.InetAddress;
  import java.net.Socket;
  
  public class SocketServerThread extends Thread {
    private Socket socket;
    private InetAddress inetAddress;
  
    public SocketServerThread(Socket socket, InetAddress inetAddress) {
      this.socket = socket;
      this.inetAddress = inetAddress;
    }
  
    @Override
    public void run() {
      // TODO Auto-generated method stub
      InputStream inputStream = null;
      InputStreamReader inputStreamReader = null;
  
      BufferedReader bufferedReader = null;
  
      OutputStream outputStream = null;
      OutputStreamWriter outputStreamWriter = null;
  
      try {
        inputStream = socket.getInputStream();
        inputStreamReader = new InputStreamReader(inputStream, "UTF-8");
  
        bufferedReader = new BufferedReader(inputStreamReader);
  
        // temp store
        String info = null;
        StringBuffer stringBuffer = new StringBuffer();
        while ((info = bufferedReader.readLine()) != null) {
          stringBuffer.append(info);
          System.out.println("client ip:" + socket.getInetAddress());
          System.out.println("client say:" + info);
  
        }
        // closs inputstream
        // socket.shutdownInput();
  
        outputStream = socket.getOutputStream();
        outputStreamWriter = new OutputStreamWriter(outputStream, "UTF-8");
        // package
        StringBuffer stringReply = new StringBuffer();
        stringReply.append("{'to_client':{");
        stringReply.append("server_ip:" + inetAddress.getHostAddress() + ",");
        stringReply.append("server_message:" + "服务器很好，勿念");
        stringReply.append("}");
        // outstream
        outputStreamWriter.write(stringReply.toString());
        // clear buffer
        outputStreamWriter.flush();
      } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
      } finally {
        try {
          outputStreamWriter.close();
          outputStream.close();
          bufferedReader.close();
          inputStreamReader.close();
          inputStream.close();
          socket.close();
        } catch (IOException e) {
          // TODO Auto-generated catch block
          e.printStackTrace();
        }
      }
  
    }
  }
  ```

  

  **SocketClient.java**

  ```java
  import java.io.BufferedReader;
  import java.io.IOException;
  import java.io.InputStream;
  import java.io.InputStreamReader;
  import java.io.OutputStream;
  import java.io.OutputStreamWriter;
  import java.net.InetAddress;
  import java.net.Socket;
  import java.net.UnknownHostException;
  import java.util.Scanner;
  
  public class SocketClient {
    public static void main(String[] args) {
      // connect target ip
      Socket socket = null;
      OutputStream outputStream = null;
      OutputStreamWriter outputStreamWriter = null;
      InputStream inputStream = null;
      InputStreamReader inputStreamReader = null;
      BufferedReader bufferedReader = null;
      try {
        socket = new Socket("127.0.0.1", 10086);
        outputStream = socket.getOutputStream();
        outputStreamWriter = new OutputStreamWriter(outputStream,"UTF-8");
        System.out.println("input content:");
        Scanner scanner = new Scanner(System.in);
        String data = scanner.nextLine();
        outputStreamWriter.write(data);
        // refresh buffer
        outputStreamWriter.flush();
  
        // close stream ;dont close connection
        socket.shutdownOutput();
  
        inputStream = socket.getInputStream();
        inputStreamReader = new InputStreamReader(inputStream,"UTF-8");
        bufferedReader = new BufferedReader(inputStreamReader);
        String info = null;
        System.out.println("客户端收到一条消息：");
        while ((info = bufferedReader.readLine()) != null) {
          System.out.println("server消息:" + info);
        }
        outputStream.close();
        outputStreamWriter.close();
        inputStream.close();
        inputStreamReader.close();
        bufferedReader.close();
      } catch (UnknownHostException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
      } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
      } 
    }
  }
  ```

  

# 线程通信方案

- 全局变量

- Handler

- Semaphore

- countDownLatch

- 管道

- ThreadLocal

- EventBus

  