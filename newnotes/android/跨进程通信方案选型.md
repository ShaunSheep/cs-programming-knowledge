# 跨进程通信方案

# 原生方案

| 对比项管道Pipe             | 管道Pipe                                                     | socket                                                       | binder | AIDL                                                         | MemoryFIle | signal                         | FileObserver | UrlScheme                                          | Messenger |
| -------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------ | ------------------------------------------------------------ | ---------- | ------------------------------ | ------------ | -------------------------------------------------- | --------- |
| wiki                       | [Pipe](https://docs.oracle.com/javase/7/docs/api/java/nio/channels/Pipe.html)<br>[PipedWriter](https://developer.android.google.cn/reference/java/io/PipedWriter?hl=en)<br>[PipedReader](https://developer.android.google.cn/reference/java/io/PipedReader?hl=en) | [Socket ](https://docs.oracle.com/javase/7/docs/api/java/net/Socket.html)<br>[ServerSocket](https://docs.oracle.com/javase/7/docs/api/java/net/ServerSocket.html) |        |                                                              |            |                                |              |                                                    |           |
| 支持双向                   | NO                                                           | YES                                                          |        |                                                              |            |                                |              |                                                    |           |
| 支持本进程（多个线程）通信 | YES                                                          | YES                                                          |        |                                                              |            |                                |              |                                                    |           |
| 支持启动者数量(类型)       | 不限                                                         | 不限                                                         |        |                                                              |            |                                |              | Activity\Service\BroadcastReceiver\ContentProvider |           |
| 支持事件总线               |                                                              | YES                                                          |        |                                                              |            |                                |              |                                                    |           |
| 支持返回结果Callback       | NO                                                           | YES                                                          |        | YES                                                          |            |                                |              |                                                    |           |
| 数据到达率高低             | YES                                                          | YES                                                          |        |                                                              |            |                                |              |                                                    |           |
| 数据最大长度               | 1024byte<br>管道流默认1024个字符                             | 65536                                                        |        |                                                              |            |                                |              |                                                    |           |
| 数据传输速度               |                                                              |                                                              |        |                                                              |            |                                |              |                                                    |           |
| 数据拷贝次数               |                                                              | 2<br>客户端拷贝一次，服务端拷贝一次                          |        |                                                              |            |                                |              |                                                    |           |
| 优点                       |                                                              | 支持设置超时时间                                             |        |                                                              |            |                                |              |                                                    |           |
| 缺点                       |                                                              | 客户端和服务端需要各自维护一个子线程监听数据传输             |        | 仅适合在不同App之间使用<br/>发生异常不回返回调用者<br/>必须使用Service，需要考虑兼容系统版本 |            | 不能传递复杂消息，只能用来同步 |              |                                                    |           |
| 本质                       | IO流                                                         | 传输层网络协议                                               |        |                                                              |            |                                |              |                                                    |           |

- AIDL仅适合：不同App通过IPC访问服务、服务中需要多线程处理
- 不跨App，建议使用Binder执行并发IPC
- 不跨App,且不存在多线程并发，建议使用Messager

# 开源方案

| 对比项               | [Andromeda](https://github.com/iqiyi/Andromeda/blob/master/CHINESE_README.md) | [Hermes\HermesEventBus](https://github.com/Xiaofei-it/HermesEventBus/blob/master/README-zh-CN.md) | [ModularizationArchitecture](https://github.com/SpinyTech/ModularizationArchitecture) | [CC](https://github.com/luckybilly/CC/wiki)                  | ActivityRouter |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------- |
| 参考wiki             | [跨进程通信框架Andromeda解析架](https://blog.csdn.net/u012165769/article/details/113006210) |                                                              |                                                              | [CC:业界首个支持渐进式组件化改造的Android组件化框架 ](https://qibilly.com/CC-website/#/) |                |
| 开源时间             | 2018年1月                                                    | 2016年6月                                                    | 2017年1月                                                    | 2017年11月                                                   |                |
| 支持双向             | YES                                                          |                                                              |                                                              |                                                              |                |
| 支持本进程通信       | YES                                                          | YES                                                          |                                                              | YES                                                          |                |
| 支持启动者数量       | Fragment\Activity                                            |                                                              |                                                              |                                                              |                |
| 支持事件总线         | YES                                                          | YES                                                          |                                                              |                                                              |                |
| 支持返回结果Callback | YES                                                          | NO                                                           |                                                              | YES                                                          |                |
| 数据到达率高低       |                                                              |                                                              |                                                              |                                                              |                |
| 数据最大长度         |                                                              |                                                              |                                                              |                                                              |                |
| 数据传输速度         |                                                              |                                                              |                                                              |                                                              |                |
| 数据拷贝次数         |                                                              |                                                              |                                                              |                                                              |                |
| 缺点                 |                                                              | 不支持oneway、in、out、inout                                 |                                                              | 仅支持开发期间                                               |                |
| 本质                 | **AIDL**                                                     | **AIDL**                                                     |                                                              | **AIDL**                                                     |                |
| 开发者               | 爱奇艺                                                       | 饿了么                                                       |                                                              |                                                              |                |

# 原生方案

## 管道

### Pipe

- #### [文档地址](https://docs.oracle.com/javase/7/docs/api/java/nio/channels/Pipe.html)

- #### 相关API：
  
  - `Pipe`类`open()`、`sink()`、`source()`;
  - `CountDownLatch`类`countDown()`、`await()`
- `ByteBuffer`类`allocate()`、f`lip()`、`clear()`、`array()`
  
- #### Demo设计

  ![Pipe](http://cdn.yangchaofan.cn/typora/Pipe.png)

- #### Demo代码

  **Test.java**

  ```java
  import java.io.IOException;
  import java.nio.ByteBuffer;
  import java.nio.channels.Pipe;
  import java.util.concurrent.CountDownLatch;
  
  public class PipeTest {
    public static void main(String[] args) {
      try {
        CountDownLatch countDownLatch = new CountDownLatch(1);
        Pipe pipe = Pipe.open();
        Sender senderThread = new Sender(pipe, countDownLatch);
        Receiver receiverThread = new Receiver(pipe, countDownLatch);
        senderThread.start();
        receiverThread.start();
      } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
      }
    }
  }
  ```

  

  **Sender.java**

  ```java
  import java.io.IOException;
  import java.nio.ByteBuffer;
  import java.nio.channels.Pipe;
  import java.util.concurrent.CountDownLatch;
  
  public class Sender extends Thread {
  
    private Pipe pipe;
    private Pipe.SinkChannel sinkChannel;
    private CountDownLatch latch;
  
    public Sender(Pipe pipe, CountDownLatch latch) {
      this.pipe = pipe;
      this.sinkChannel = pipe.sink();
      this.latch = latch;
    }
  
    @Override
    public void run() {
      // test input content
      StringBuffer stringBuffer = new StringBuffer();
      for (int i = 0; i < 3; i++) {
        String outData = "jack：" + (i + 1) + " times good moring";
        stringBuffer.append(outData);
      }
      ByteBuffer buffer = ByteBuffer.allocate(1024);
      buffer.clear();
      buffer.put(String.valueOf(stringBuffer).getBytes());
      buffer.flip();
      try {
        while (buffer.hasRemaining()) {
          sinkChannel.write(buffer);
        }
      } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
      } finally {
        System.out.println("senderThread send content:" + stringBuffer.toString());
        latch.countDown();
        System.out.println("senderThread send finish:");
      }
    }
  }
  
  ```

  

  **Receiver.java**

  ```java
  import java.io.IOException;
  import java.nio.ByteBuffer;
  import java.nio.channels.Pipe;
  import java.util.concurrent.CountDownLatch;
  
  public class Receiver extends Thread {
    private Pipe pipe;
    private Pipe.SourceChannel sourceChannel;
    private CountDownLatch latch;
  
    public Receiver(Pipe pipe, CountDownLatch latch) {
      this.pipe = pipe;
      this.latch = latch;
      this.sourceChannel = pipe.source();
    }
  
    @Override
    public void run() {
      try {
        latch.await();
      } catch (InterruptedException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
      }
      ByteBuffer buffer = ByteBuffer.allocate(1024);
      int len = 0;
      StringBuffer stringBuffer = new StringBuffer();
      try {
        len = sourceChannel.read(buffer);
        buffer.flip();
        String content = new String(buffer.array(), 0, len);
        stringBuffer.append(content);
        buffer.clear();
      } catch (Exception exception) {
        exception.printStackTrace();
      } finally {
        System.out.println("ReceiverThread has receive content:" + stringBuffer);
      }
  
    }
  
  }
  ```

### PipeReader、PipeWriter

- #### [文档地址](https://developer.android.google.cn/reference/java/io/PipedWriter?hl=en)

- #### 相关API
  
  - `PipedWriter`类`write()`
  - `PipedReade`r类`PipedWriter(PipedWriter)`、`read(buffer)`、`connect()`
  - `CountDownLatch`类`countDown()`、`await()`
  - `CharBuffer`类`allocate()`、f`lip()`、`clear()`、`array()`
- #### Demo设计

![跨进程通信调研-PipedWriter](http://cdn.yangchaofan.cn/typora/跨进程通信调研-PipedWriter.png)

- #### Demo代码

  **Test.java**

  ```java
  import java.io.IOException;
  import java.io.PipedReader;
  import java.io.PipedWriter;
  import java.util.concurrent.CountDownLatch;
  import java.util.concurrent.ExecutorService;
  import java.util.concurrent.Executors;
  
  public class PipedReaderTest {
    public static void main(String[] args) {
      try {
        CountDownLatch countDownLatch = new CountDownLatch(1);
        PipedWriter pipedWriter = new PipedWriter();
        PipedReader pipedReader = new PipedReader(pipedWriter);
        Sender sender = new Sender(pipedWriter,countDownLatch);
        Receiver receiver = new Receiver(pipedReader, pipedWriter,countDownLatch);
        ExecutorService service = Executors.newCachedThreadPool();
        service.execute(sender);
        service.execute(receiver);
      } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
      }
    }
  
  }
  ```

  

  **Sender.java**

  ```java
  import java.io.IOException;
  import java.io.PipedWriter;
  import java.util.concurrent.CountDownLatch;
  
  public class Sender implements Runnable {
    PipedWriter pipedWriter;
    CountDownLatch latch;
  
    public Sender(PipedWriter pipedWriter, CountDownLatch latch) {
      this.pipedWriter = pipedWriter;
      this.latch = latch;
    }
  
    @Override
    public void run() {
      try {
        // TODO Auto-generated method stub
        StringBuffer stringBuffer = new StringBuffer();
        for (char a = 'a'; a <= 'z'; a++) {
          stringBuffer.append(a);
        }
        pipedWriter.write(stringBuffer.toString().toCharArray(), 0, stringBuffer.length());
        System.out.println("sedner content :"+stringBuffer);
      } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
      } finally {
        latch.countDown();
        System.out.println("sedner has finish");
      }
    }
  }
  ```

  **Receiver.java**

  ```java
  import java.io.IOException;
  import java.io.PipedReader;
  import java.io.PipedWriter;
  import java.nio.ByteBuffer;
  import java.nio.CharBuffer;
  import java.util.concurrent.CountDownLatch;
  
  public class Receiver implements Runnable {
    private PipedWriter pipedWriter;
    private PipedReader pipedReader;
    private CountDownLatch latch;
  
    public Receiver(PipedReader pipedReader, PipedWriter pipedWriter, CountDownLatch latch) {
      this.pipedReader = pipedReader;
      this.pipedWriter = pipedWriter;
      this.latch = latch;
    }
  
    @Override
    public void run() {
      try {
        latch.await();
        StringBuffer stringBuffer = new StringBuffer();
        CharBuffer buffer = CharBuffer.allocate(1024);
        int len =  pipedReader.read(buffer);
        buffer.flip();
        String a = new String(buffer.array(),0,len);
        stringBuffer.append(a);
        buffer.clear();
        System.out.println("receiver content:" + stringBuffer);
      } catch (IOException | InterruptedException e) {
        e.printStackTrace();
      } finally {
        System.out.print("receiver has finish");
      }
    }
  
  }
  ```


## Socket

- [文档地址](https://docs.oracle.com/javase/7/docs/api/java/net/Socket.html)

- 相关API

  - `ServerSocket`类：`accept() `
  - `Socket`类：`getInputStream()` 、`getOutputStream()`
  - `PrintStream`类：`println()`
  - `BufferedReader`类：`readLine()`
  - `System`类：`System.in`
  - Collections

- Demo设计

  ![跨进程通信调研-Socket](http://cdn.yangchaofan.cn/typora/跨进程通信调研-Socket.png)

- Demo代码

  **MySever.java**

  ```java
  import java.io.IOException;
  import java.net.ServerSocket;
  import java.net.Socket;
  import java.util.ArrayList;
  import java.util.Collections;
  import java.util.List;
  
  public class MySever {
      public static List<Socket> socketList = Collections.synchronizedList(new ArrayList<>());
  
      public static void main(String[] args) {
          try {
              ServerSocket serverSocket = new ServerSocket(10086);
              System.out.println("服务器启动");
              int count = 0;
              while (true) {
                  Socket s = serverSocket.accept();
                  System.out.println("识别到新用户进入:");
                  count++;
                  socketList.add(s);
                  new Thread(new ServerThread(s)).start();
                  System.out.println("client enter chat home successful!");
                  System.out.println("chat room has"+count+" users");
              }
          } catch (IOException e) {
              // TODO Auto-generated catch block
              e.printStackTrace();
          }
      }
  }
  ```
  
  
  
  **ServerThread.java**

  ```java
import java.io.BufferedReader;
  import java.io.IOException;
import java.io.InputStreamReader;
  import java.io.PrintStream;
  import java.net.InetAddress;
  import java.net.Socket;
  
  public class ServerThread implements Runnable {
      Socket Socket;
      BufferedReader br = null;
  
      public ServerThread(Socket socket) {
          this.Socket = socket;
          try {
              this.br = new BufferedReader(new InputStreamReader(socket.getInputStream()));
          } catch (IOException e) {
              // TODO Auto-generated catch block
              e.printStackTrace();
          }
      }
  
      @Override
      public void run() {
          // TODO Auto-generated method stub
          String conent = null;
          while ((conent = readFromClient()) != null) {
              for (Socket s : MySever.socketList) {
                  PrintStream printStream;
                  try {
                      printStream = new PrintStream(s.getOutputStream());
                      // client message print
                      System.out.println("server receive message:" + conent);
                      InetAddress inetAddress = s.getInetAddress();
                      StringBuffer stringReply = new StringBuffer();
                      stringReply.append("{'to_client':{");
                      stringReply.append("client_ip:" + inetAddress.getHostAddress() + ",");
                      stringReply.append("server_message:" + "服务器很好，勿念");
                      stringReply.append("}}");
                      // response message to client
                      printStream.println("server say:" + stringReply + " ,by");
                  } catch (IOException e) {
                      // TODO Auto-generated catch block
                      e.printStackTrace();
                  }
              }
          }
      }
  
      private String readFromClient() {
          try {
              return br.readLine();
          } catch (IOException e) {
              // TODO Auto-generated catch block
              e.printStackTrace();
              MySever.socketList.remove(Socket);
          }
          return null;
      }
  
  }
  ```
  
  
  
  **MyClient.java**
  
  ```java
  import java.io.BufferedReader;
  import java.io.IOException;
  import java.io.InputStreamReader;
  import java.io.PrintStream;
  import java.net.Socket;
  import java.net.UnknownHostException;
  
  public class MyClient {
      public static void main(String[] args) throws UnknownHostException, IOException {
          Socket socket = new Socket("127.0.0.1", 10086);
          new Thread(new ClientThread(socket)).start();
          PrintStream printStream = new PrintStream(socket.getOutputStream());
          String line = null;
          BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
          while ((line = bufferedReader.readLine()) != null) {
              printStream.println(line);
        }
      }
}
  ```

  **ClientThread.java**
  
  ```java
  import java.io.BufferedReader;
  import java.io.IOException;
  import java.io.InputStreamReader;
  import java.net.Socket;
  
  public class ClientThread implements Runnable {
      Socket socket;
      BufferedReader bufferedReader = null;
  
      public ClientThread(Socket socket) {
          this.socket = socket;
          try {
              bufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream()));
          } catch (IOException e) {
              // TODO Auto-generated catch block
              e.printStackTrace();
          }
      }
  
      @Override
      public void run() {
          // TODO Auto-generated method stub
          String conent = null;
          try {
              while ((conent = bufferedReader.readLine()) != null) {
                  System.out.println(conent);
              }
          } catch (IOException e) {
              // TODO Auto-generated catch block
              e.printStackTrace();
          }
      }
  }
  ```



## AIDL

- [文档地址](https://developer.android.google.cn/guide/components/aidl?hl=zh_cn)
- 相关API
- Demo设计
- Demo代码
- [与Service实现双向通信（三） (race604.com)](https://www.race604.com/communicate-with-remote-service-3/)



# 线程通信方案

- 全局变量

- Handler

- Semaphore

- countDownLatch

- 管道

- ThreadLocal

- EventBus

  



# 问题集合

## Service Intent must be explicit: Intent 

- 使用隐式意图的话，加上包名信息即可；

```java
Intent intent = new Intent();  
intent.setAction("com.yulore.recognize.android");  
intent.setPackage(context.getPackageName());    //兼容Android 5.0  
context.startService(intent);  
```

- 显示意图

```java
Intent intent = new Intent(com.yulore.test.AppService.class);  
context.startService(intent);  
```

