# 递归Recursive

语义的角度解释递归：还能递归吗？还能查到第n-i项吗？

伪代码的角度解释递归：

```shell
f(i) = f(i-1)*2+1;

f(n)=>f(n-1)+1
    =>f(n-2)+1+1
    =>
    =>
```
## 学习递归的目的

- 使用递归来归纳某些问题非常快捷，很容易编写实现代码
- 积累优化递归的方法
- 积累优化尾递归的方法
- 积累消除递归的方法

## 递归关联的算法
?> 这些递归深度都是$O(log(N))$,注意递归深度与时间复杂度是两个概念
- 快速排序
- 归并排序
- 平衡二叉树遍历
- LCS二叉树最近公共祖先

## 前置知识-字节、位、字节数

- 位(bit)：通常表示2进制位，一个2进制位用0或1表示，1个位占据一个方块内存；bit是计算机`数据存储`的最小单位
- 字节(byte)：8位表示一个字节，即8个方块表示1个字节,`1byte = 8bit`，计算机中的1B大小，就是指1byte，byte也是计算机的`数据处理`基本单位
- Java语法中的字节，即byte数据类型，
  - 根据`字节`概念，一个Java `byte`对应`8`位，即`8`个方块，每个方块表示`0`或`1`，
  - 以此类推，Java语法中，`int`对应`4`个字节，即`4*byte(8) = 32`位，即`32`个方块，每个方块表示`0`或`1`，
  - `short`对应2个字节，即`2*8 = 16`位，即`16`个方块的内存，每个方块表示`1`或`1`

<img src="http://cdn.yangchaofan.cn/BlogGifRes/20210411/StatL7rYknxO.png">

## 递归概念

###  递归三要素

一种称法是递归实例、递归基、尾递归

另一种说法是递归定义、递归出口(终止递归的条件)、递归表达式(规律)



### 复杂度评估

```shell
T(n) = T(n/2) + O(1)
     = T(n/4) + O(1) + O(1)
     = T(n/8) + O(1) * 3
     = T(n/16) + O(1) * 4
     =  T(n/2^x)+O(1)*x => 为第x项公式
     ...
     = T(1) + O(1) * logn => 推导出 n/n =1 => n = 2^x =>
     = O(logn)

```
`2^x=n => log2n=x` 项，底数`2`通常省略，所以`n n/2 n/4 n/8 ... 1`,可得一共是`logn`项
<img src="https://exp-picture.cdn.bcebos.com/b955ead0b503c8d2d4a8a4fc498333bf3aef21e9.jpg">

### 内存计算

每一层递归实例，都有独立地入参变量，返回值变量，局部变量
递归10层，会创建10个该方法，会占据10个单位空间的内存

?>堆空间、栈空间

函数创建的时候，有局部变量、入参变量、返回值变量等，都需要开辟空间来存储，这些就存储在栈空间中。栈空间是泛指，JVM中有虚拟机栈、本地方法栈等。

?>堆空间、栈空间区别

`int[] nums = new int[]{1,2,3,4}`
这里 `nums` 可以理解为两个部分：

- 一个名字叫做` nums `的局部变量，他存储了指向内存空间的一个地址（Reference），这个地址也就是 `4` 个字节（32位地址总线的计算机，地址大小为 4 字节）
- 后面一个部分是`new `出来的，一共有 `n` 个位置的整数数组，`int[n]`。一共有` 4 * n` 个字节。

这里 `nums `这个变量本身，是存储在栈空间的，因为他是一个局部变量。但是` nums `里存储的` n `个整数，是存储在堆空间里的，`Heap space`。他并不占用栈空间，并不会导致栈溢出。

### 递归深度
?> 递归深度是什么？

答：递归深度就是递归函数在内存中，同时存在的最大个数。
例如下面这段求阶乘的代码是$O(n)$：

```java
int factorial(int n) {
    if (n == 1) {
        return 1;
    }
    return factorial(n - 1) * n;
}
```

例如二分查找，递归深度是$O(log(n))$

### 栈溢出

?>递归深度与栈溢出存在什么关系？

答：深度越深，越有可能溢出。
首先，函数本身也是在内存中占空间的，主要用于存储传递的参数，以及调用代码的返回地址。

函数的调用，会在内存的栈空间中开辟新空间，来存放子函数。递归函数更是会不断占用栈空间，例如该阶乘函数，展开到最后`n=1`时，内存中会存在`factorial(100)`, `factorial(99)`, `factorial(98)` ... `factorial(1)`这些函数，它们从栈底向栈顶方向不断扩展。

当递归过深时，栈空间会被耗尽，这时就无法开辟新的函数，会报出`stack overflow`这样的错误。所以，在考虑空间复杂度时，递归函数的深度也是要考虑进去的。


### 尾递归
**尾递归定义：**

若递归函数中，递归调用是整个函数体中最后的语句，且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归。（上例`factorial`函数满足前者，但不满足后者，故不是尾递归函数）。

**尾递归函数的特点是：**在递归展开后该函数不再做任何操作，这意味着该函数可以不等子函数执行完，自己直接销毁，这样就不再占用内存。一个递归深度$O(n)$的尾递归函数，可以做到只占用$O(1)$空间。这极大的优化了栈空间的利用。

!>要注意，这种内存优化是由编译器决定是否要采取的，不过大多数现代的编译器会利用这种特点自动生成优化的代码。在实际工作当中，尽量写尾递归函数，是很好的习惯。

在算法题当中，计算空间复杂度时，建议还是老老实实地算空间复杂度了，尾递归这种优化提一下也是可以，但别太在意。


## 递归优化

- 递归消除
- 尾递归



## 缺点

1. 递归深度过深，会导致栈溢出
2. 很多算法题的递归实现，看不懂，很难想象出来其过程，只能死记硬背

# 递归相关题目

## 斐波纳契数列

[题目链接](https://leetcode-cn.com/problems/fibonacci-number/)

斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：

F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
给你 n ，请计算 F(n)

### 递归版

```java
class Solution {
    public int fib(int n) {
        if(n == 0) return 0;
        else if(n == 1) return 1;
        else return fib(n - 1) + fib(n - 2);
    }
}
```



### 非递归版

```java
class Solution {
    public int fib(int N) {
        int g = 1;
        int f = 0;
        while (0 < N--) {
            g = g + f;
            f = g - f;
        }
        return f;
    }
}
```



## 经典二分查找

这道题目已经做过，点击链接查看[经典二分查找](newnotes/leetcode/经典二分查找?id=经典二分查找)

# 递归的通俗解释

**函数调用自身**

- 自身任务已经完成了

```java
public void method(..){
    ...
    method(..); // 第i层执行到了这里
    doSth();// 到这一行的时候，method已经完成了i层的任务,
    ...
}
```



**脱衣服**

- ```python
  衣服 = xxxx

  def 脱衣服():

      if 衣服 == 0:  #边界条件

          做该做的事()  #边界处理

          return

      衣服 = 衣服 - 1 #递归压栈前状态改变

      脱衣服()  #递归情况

      衣服 = 衣服 + 1 #递归弹栈后状态改变

  ```

  

**斐波那契**

- ![mark](http://cdn.yangchaofan.cn/BlogGifRes/20210612/UBYc0eiG3fyS.gif)

**洋葱**

- 一个洋葱是一个带着一层洋葱皮的洋葱。

**查词典**

- 我们使用的词典，本身就是递归，为了解释一个词，需要使用更多的词。
  当你查一个词，发现这个词的解释中某个词仍然不懂，于是你开始查这第二个词，可惜，第二个词里仍然有不懂的词，于是查第三个词，这样查下去，直到有一个词的解释是你完全能看懂的，那么递归走到了尽头，然后你开始后退，逐个明白之前查过的每一个词，最终，你明白了最开始那个词的意思。作者：李鹏

# 递归的小资料

1. 老邓头数据结构与算法
2. 九章算法2020
3. [漫谈递归13部曲：递归的思想](http://www.nowamagic.net/librarys/veda/detail/2314)
4. [How should I explain recursion to a 4-year-old?](https://link.zhihu.com/?target=https%3A//www.quora.com/How-should-I-explain-recursion-to-a-4-year-old)



