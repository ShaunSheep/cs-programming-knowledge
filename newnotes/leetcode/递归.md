# 递归Recursive

语义的角度解释递归：还能递归吗？还能查到第n-i项吗？

伪代码的角度解释递归：

```shell
f(i) = f(i-1)*2+1;

f(n)=>f(n-1)+1
    =>f(n-2)+1+1
    =>
    =>
```
## 学习递归的目的

- 使用递归来归纳某些问题非常快捷，很容易编写实现代码
- 积累优化递归的方法
- 积累优化尾递归的方法
- 积累消除递归的方法

## 递归关联的算法
?> 这些递归深度都是$O(log(N))$,注意递归深度与时间复杂度是两个概念
- 快速排序
- 归并排序
- 平衡二叉树遍历

## 前置知识-字节、位、字节数

- 位(bit)：通常表示2进制位，一个2进制位用0或1表示，1个位占据一个方块内存；bit是计算机`数据存储`的最小单位
- 字节(byte)：8位表示一个字节，即8个方块表示1个字节,`1byte = 8bit`，计算机中的1B大小，就是指1byte，byte也是计算机的`数据处理`基本单位
- Java语法中的字节，即byte数据类型，
  - 根据`字节`概念，一个Java `byte`对应`8`位，即`8`个方块，每个方块表示`0`或`1`，
  - 以此类推，Java语法中，`int`对应`4`个字节，即`4*byte(8) = 32`位，即`32`个方块，每个方块表示`0`或`1`，
  - `short`对应2个字节，即`2*8 = 16`位，即`16`个方块的内存，每个方块表示`1`或`1`

<img src="http://cdn.yangchaofan.cn/BlogGifRes/20210411/StatL7rYknxO.png">

## 递归概念

?> 递归三要素

递归实例，递归基，尾递归

### 复杂度评估

```shell
T(n) = T(n/2) + O(1)
     = T(n/4) + O(1) + O(1)
     = T(n/8) + O(1) * 3
     = T(n/16) + O(1) * 4
     =  T(n/2^x)+O(1)*x => 为第x项公式
     ...
     = T(1) + O(1) * logn => 推导出 n/n =1 => n = 2^x =>
     = O(logn)

```
`2^x=n => log2n=x` 项，底数`2`通常省略，所以`n n/2 n/4 n/8 ... 1`,可得一共是`logn`项
<img src="https://exp-picture.cdn.bcebos.com/b955ead0b503c8d2d4a8a4fc498333bf3aef21e9.jpg">

### 内存计算

每一层递归实例，都有独立地入参变量，返回值变量，局部变量
递归10层，会创建10个该方法，会占据10个单位空间的内存

?>堆空间、栈空间

函数创建的时候，有局部变量、入参变量、返回值变量等，都需要开辟空间来存储，这些就存储在栈空间中。栈空间是泛指，JVM中有虚拟机栈、本地方法栈等。

?>堆空间、栈空间区别

int[] nums = new int[]{1,2,3,4}
这里 nums 可以理解为两个部分：
一个名字叫做 nums 的局部变量，他存储了指向内存空间的一个地址（Reference），这个地址也就是 4 个字节（32位地址总线的计算机，地址大小为 4 字节）
new 出来的，一共有 n 个位置的整数数组，int[n]。一共有 4 * n 个字节。
这里 nums 这个变量本身，是存储在栈空间的，因为他是一个局部变量。但是 nums 里存储的 n 个整数，是存储在堆空间里的，Heap space。他并不占用栈空间，并不会导致栈溢出。

### 递归深度
?> 递归深度是什么？

答：递归深度就是递归函数在内存中，同时存在的最大个数。
例如下面这段求阶乘的代码是O(n
.)：
Java:
int factorial(int n) {
    if (n == 1) {
        return 1;
    }
    return factorial(n - 1) * n;
}
例如二分查找，递归深度是O(log(n))

### 栈溢出

?>递归深度与栈溢出存在什么关系？

答：深度越深，越有可能溢出。
首先，函数本身也是在内存中占空间的，主要用于存储传递的参数，以及调用代码的返回地址。
函数的调用，会在内存的栈空间中开辟新空间，来存放子函数。递归函数更是会不断占用栈空间，例如该阶乘函数，展开到最后n=1时，内存中会存在factorial(100), factorial(99), factorial(98) ... factorial(1)这些函数，它们从栈底向栈顶方向不断扩展。
当递归过深时，栈空间会被耗尽，这时就无法开辟新的函数，会报出stack overflow这样的错误。
所以，在考虑空间复杂度时，递归函数的深度也是要考虑进去的。


### 尾递归
答：尾递归：若递归函数中，递归调用是整个函数体中最后的语句，且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归。（上例factorial函数满足前者，但不满足后者，故不是尾递归函数）
尾递归函数的特点是：在递归展开后该函数不再做任何操作，这意味着该函数可以不等子函数执行完，自己直接销毁，这样就不再占用内存。一个递归深度O(n)的尾递归函数，可以做到只占用O(1)空间。这极大的优化了栈空间的利用。
但要注意，这种内存优化是由编译器决定是否要采取的，不过大多数现代的编译器会利用这种特点自动生成优化的代码。在实际工作当中，尽量写尾递归函数，是很好的习惯。
而在算法题当中，计算空间复杂度时，建议还是老老实实地算空间复杂度了，尾递归这种优化提一下也是可以，但别太在意。


## 递归优化

- 递归消除
- 尾递归



## 缺点

1. 递归深度过深，会导致栈溢出

# 递归相关题目

## 斐波纳契数列

### 递归版

### 非递归版

## 经典二分查找

