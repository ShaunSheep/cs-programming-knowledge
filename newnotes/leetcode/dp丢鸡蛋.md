
#  丢鸡蛋

## 题目链接

[丢鸡蛋](https://www.lintcode.com/problem/254/?_from=collection&fromId=161)

## 题目描述

描述

楼有 `n` 层高，鸡蛋若从 *k* 层或以上扔，就会碎。从 *k* 层以下扔，就不会碎。

现在给两个鸡蛋，用最少的扔的次数找到 *k*。返回最坏情况下次数。

对于 n = 10， 一种找 *k* 的初级方法是从 1、2 ... k 层不断找。但最坏情况下要扔 10 次。注意有两个鸡蛋可以使用，所以可以从 4、7、9 层扔。这样最坏就只需要 4 次 (例如 k = 9 时)。

样例

**样例 1：**

```
输入：100
输出：14
```

**样例 2：**

```
输入：10
输出：4
```

## 解题思路

| <div style="width:70pt">方法</div>  |描述 |<div style="width:70pt">时间复杂度</div> |<div style="width:70pt">空间复杂度</div>|
|---|---|---|---|
|  动态规划法 | 下文代码实现  | $O(1)$|$(1)$|

题意解释：
有两个鸡蛋可以扔，也就是第一个鸡蛋若是碎了，那么第二个鸡蛋必须不能出错，得从确定不会碎的楼层x开始，一层一层向上试，直到找到答案。若从1到5逐一尝试，那么最坏情况就是5次，而现在要求在最坏情况下，最少的扔鸡蛋次数。以n=10时为例，下图展示了两种策略方案。

图片

![图片](https://media-test.jiuzhang.com/media/markdown/images/6/3/9ebacde4-a585-11ea-a3cf-0242c0a8b005.jpg)

注：红色箭头表示若在当前楼层第一个鸡蛋碎了，蓝色表示鸡蛋未碎。

上图可见，我们要求的最坏情况扔鸡蛋次数即图中情况树的深度，左图需扔4次，右图需扔10次。而题目求最小的次数，即如何安排决策可以使得这棵树的深度最小。可见，当我们安排每一种情况的所有叶子节点高度越平均，树的深度越小。

解题思路：
故可以想到，假设第一次从x层开始扔，那么若鸡蛋碎了，需要从1到x - 1逐层尝试,那么共需尝试x次; 若第一次鸡蛋未碎，第二次尝试从y层开始，碎在y层，那么需要从x + 1到y - 1逐层尝试，共需尝试 （y - x + 1）次，那么当x = y - x + 1时（也即y = x + x - 1）,能够使得扔鸡蛋次数最小，以此类推，第一次从x层开始，那么若未碎第二次应当从x + x - 1层开始，第三次应当从x + x - 1 + x - 2层开始......

那么x的取值应当满足（1 + 2 + ... + x）>= n 即 x * (x + 1) / 2 >= n 的最小值即为答案值。

复杂度分析：
时间复杂度：若暴力从小到大搜索找x则复杂度为， 若二分查找x则复杂度为
空间复杂度：




## 代码实现

```java
public class Solution {
    /**
     * @param n an integer
     * @return an integer
     */
    public int dropEggs(int n) {
        // Write your code here
        long ans = 0;
        for (int i = 1; ; ++i) {
            ans += (long)i;
            if (ans >= (long)n)
                return i;
        }
    }
}
```