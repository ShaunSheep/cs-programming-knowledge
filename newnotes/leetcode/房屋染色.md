
#  房屋染色 · Paint House

## 题目链接

[房屋染色](https://www.lintcode.com/problem/515/)

## 题目描述

描述

这里有`n`个房子在一列直线上，现在我们需要给房屋染色，分别有红色蓝色和绿色。每个房屋染不同的颜色费用也不同，你需要设计一种染色方案使得**相邻的房屋颜色不同**，并且费用最小，返回最小的费用。

费用通过一个`n`x`3` 的矩阵给出，比如`cost[0][0]`表示房屋`0`染红色的费用，`cost[1][2]`表示房屋`1`染绿色的费用，依此类推。找到油漆所有房子的最低成本。



所有费用都是正整数

样例

**样例 1:**

```
输入: [[14,2,11],[11,14,5],[14,3,10]]
输出: 10
解释: 第一个屋子染蓝色，第二个染绿色，第三个染蓝色，最小花费：2 + 5 + 3 = 10.
```

**样例 2:**

```
输入: [[1,2,3],[1,4,6]]
输出: 3
```

## 解题思路

| <div style="width:70pt">方法</div>  |描述 |<div style="width:70pt">时间复杂度</div> |<div style="width:70pt">空间复杂度</div>|
|---|---|---|---|
|  动态规划法-序列型 | 下文代码实现  | $O(1)$|$(1)$|

最后一步：前n-1栋房子的最优解一定是刷第n-1栋为{红色，绿色，蓝色}时，加上前n-2栋房子的最优解
**状态**：`dp[i][j]`前i栋最优解，第i栋刷成颜色j时，前i栋刷成非j颜色的最小成本
**转移方程**：$f[i][0] = min（{f[i-1][1]+cost[i-1][0],f[i-1][2]+cost[i-1][0]}）$ ，

$f[i][1] = min（{f[i-1][2]+cost[i-1][1],f[i-1][0]+cost[i-1][1]}）$ ，

$f[i][2] = min（{f[i-1][1]+cost[i-1][2],f[i-1][0]+cost[i-1][2]}）$ ，

$f[i][j]=min(f[i][0],f[i][1],f[i][2])$



**初始化**：`f[0][j]=0,j=(0,1,2)`,`f[i][j]=MAX_VALUE`

**答案：**`f[n][forech 每个颜色],n=A.length`,打擂台第`i`栋所有的颜色`min(dp[i][0],dp[i][1]...dp[i][最后一个颜色])`

### 侯卫东题目类比

|          |                                                              |                                                              |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 对比项   | 房屋染色                                                     | 不同路径和II                                                 |
| 状态     | `dp[i][k]`油漆前i栋房子，且第`i`栋染成`颜色k`、且第`i-1`栋染成非k颜色的最小花费<br> | `dp[i][j]`代表从原点走向`(i,j)`的不同路径和                  |
| 转移方程 | $f[i][j]=min(f[i][0],f[i][1],f[i][2])$<br>$f[i][0] = min（{f[i-1][1]+cost[i-1][0],f[i-1][2]+cost[i-1][0]}）$ ，j=1,2类似 | `A[i][j]=1`则`dp[i][j]=0`;其他情况则`dp[i][j]=dp[i-1][j]+dp[i][j-1]` |
| 初始化   | `f[0][j]=0,j=(0,1,2)`,`f[i][j]=MAX_VALUE`                    | 5种情况，有障碍初始化；是原点初始化；第一行初始化；第一列初始化；非第一行非第一列初始化 |

## 代码实现

此题的难点在于：

1. 当第`i`栋刷成`颜色i`，第`i-1`栋如何打擂台选`非i`的颜色，技巧是双重循环判断`i和k不等`

此解法的陷阱在于：

1. 房屋计数是从1，2，..i...n的，cost计数是从0,1,.i...n-1的
2. `costs[i-1][j]`，costs的定义域属于`[0,n-1]`，costs=n-1时候代表的就是第n栋房子，房子是从1，2...n栋开始数的。
3. `dp[i][j]`指的是第i栋染j色的包括之前每一栋染色的总花费；`costs[i-1][j]`指的是第`i`栋染`j`色的花费，两者都包括了第`i`栋房子

```java
public class Solution {
    /**
     * @param costs: n x 3 cost matrix
     * @return: An integer, the minimum cost to paint all houses
     */
    public int minCost(int[][] costs) {
        // write your code here
        int n = costs.length;
        if(n == 0){
            return 0;
        }
        // 栋数是从1...n访问的
        int[][] dp = new int[n+1][3];
        // 第0栋没有任何价值，也无法被染色
        dp[0][0] = dp[0][1] = dp[0][2] = 0;
        for(int i = 1;i <= n;i++){
            // 第i栋的费用
            for(int j = 0; j < 3;j++){
                // 第i栋染成j颜色
                dp[i][j] = Integer.MAX_VALUE;
                for(int k = 0;k < 3;k++){
                    if(k != j){
                        // 第i-1 染成非j颜色
                        // cost[i-1][j]代表的就是第i栋染成j颜色的成本，因为cost的定义域是[0,i-1]
                        dp[i][j] = Math.min(dp[i][j], dp[i-1][k]+costs[i-1][j]);
                    } 
                }
            }
        }
        // return Math.min(dp[n][1],dp[n][0],dp[n][2]);
        return Math.min(dp[n][1], Math.min(dp[n][0],dp[n][2]));
    }
}
```