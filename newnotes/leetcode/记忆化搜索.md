# 记忆化搜索

# 前置知识

## 其他算法的复杂度比较表格

## 搜索

目前常接触的搜索有：
- 对数组按顺序遍历
- 对树的dfs，bfs，preorder、inorder
- 对数组分治法
- 对数组二分法

记忆化搜索与前面的搜索有哪些不同？以数字三角形为例，比较一下记忆化搜索和树的搜索

## 数字三角形
[数字三角形](https://www.lintcode.com/problem/109/)
### 题目描述
描述
给定一个数字三角形，找到从顶部到底部的最小路径和。每一步可以移动到下面一行的相邻数字上。

如果只用额外空间复杂度O(n)O(n)完成，可以获得加分，其中n是数字三角形的总行数。

样例
样例 1：

输入：
```java
triangle = [
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
```
输出：

11
解释：

从顶到底部的最小路径和为11 （ 2 + 3 + 5 + 1 = 11）。

样例 2：

输入：
```java
triangle = [
     [2],
    [3,2],
   [6,5,7],
  [4,4,8,1]
]
```
输出：

12
解释：

从顶到底部的最小路径和为12 （ 2 + 2 + 7 + 1 = 12）。
### 记忆化搜索的抽象过程
- 每一层执行完，都保存当前点到叶节点的最小路径和
- 记忆化搜索，有些节点是会重复访问的


<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 		     src="https://cdn.yangchaofan.cn/typora%E8%AE%B0%E5%BF%86%E5%8C%96%E6%B3%95%E5%81%9A%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2-%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8A%BD%E8%B1%A1%E8%BF%87%E7%A8%8B.svg" width = "100%" alt=""/>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">
      图1-手绘一下搜索思路
      </div>
</center>



<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="http://cdn.yangchaofan.cn/typora/矩阵坐标的两种抽象方式.png" width = "100%" alt=""/>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">
      图2-两种不同的坐标抽象方式
      </div>
</center>

### 树的搜索过程

!>手绘一下搜索思路
- dfs为例，先left子树遍历到叶节点，再right子树遍历到叶节点，最后汇总打擂台得出最小路径和；
- 二叉树的左右节点是不会重复访问的



### 分治法代码实现

```java
def minimumTotal(self,triangle):
	return self.divide_conquer(triangle,0,0)
 
def divide_conquer(self,triangle,x,y):
	if x == len(triangle)
        return 0
    left = self.divide_conquer(triangle,x+1,y)
    right = self.divide_conquer(triangle,x+1,y+1)
    return min(left,right)+triangle[x][y]
```



### 分治法+HashMap代码实现

用一个`{} map`记住搜索过的点

```java
class Solution:
    """
    @param triangle: a list of lists of integers
    @return: An integer, minimum path sum
    """
    def minimumTotal(self, triangle):
        return self.divide_conquer(triangle, 0, 0, {})
        
    # 函数返回从 x, y 出发，走到最底层的最短路径值
    # memo 中 key 为二元组 (x, y)
    # memo 中 value 为从 x, y 走到最底层的最短路径值
    def divide_conquer(self, triangle, x, y, memo):
        if x == len(triangle):
            return 0
            
        # 如果找过了，就不要再找了，直接把之前找到的值返回
        if (x, y) in memo:
            return memo[(x, y)]

        left = self.divide_conquer(triangle, x + 1, y, memo)
        right = self.divide_conquer(triangle, x + 1, y + 1, memo)
        
        # 在 return 之前先把这次找到的最短路径值记录下来
        # 避免之后重复搜索
        memo[(x, y)] = min(left, right) + triangle[x][y]
        return memo[(x, y)]
```

- 时间复杂度为$O(n^2)$，节点数为n，所有的点只遍历1次，共有$\frac {n\times(n+1)}{2}$个节点
- 某些条件下阻止其递归
- `triangle[x][y]`代表这一层当前节点的路径长度
- python中 `{}`的类型为map
- python中map存值方式为`memo[(x, y)]`,表明存入以`(x,y)`为key，`min(left, right) + triangle[x][y]`为value
- pythjon中以`key in map`判断是否map包含该key
- hashmap的key为坐标点，value为以该节点为起始点，最短路径和



# 记忆化搜索定义

## 定义

使用HashMap记录搜索的中间结果从而避免重复访问的算法，就叫做记忆化搜索

# 搜索的类型

1. traverse-遍历

2. divide conquer-分治递归

3. divide conquer+map-记忆化搜索

## 记忆化搜索与树分治遍历的联系



**相同**

- 都有大问题分成小问题的思想

**不同**

- 记忆化搜索，需要存储已经访问过的节点，下次输入相同参数，就不再进行遍历了
- 树的搜索，树的节点没有重复访问的情况，所以不需要存储已经访问过的点的操作结果

> 树的dfs也会使用visited变量、hashmap存一些点是否访问，这难道不是记忆化的特征吗？

- 记忆化的特征是要记住该点的访问结果，即上一次遍历这个点的时候，该点的路径和、子节点的数量等扥，目的是记住上次的结果，使用哈希表的形式促成南湖
- 树的特征是，用visited布尔数组，记录这个点有没有访问，有访问，下次就不访问了，目的是去重
  简而言之，两者的临时变量的功能不同，记忆化的临时变量作用是记住上次访问的结果；树的临时变量作用是去重保证不再二次访问即可。

## 记忆化搜索优化与分治+map 的联系

就是一回事。

## 记忆化搜索与CPUcache的联系

都关注的是把已经访问过的存起来，下次能更快的得到该结果。

# 记忆化搜索优点和缺点

## 优点

能将指数级别的时间复杂度降低到多项式级别，如数字三角形题目从$2^n$降低到$n^2$

## 缺点

StackOverflow，递归深度过深，容易溢出。

尤其是时间复杂度是O(n)的，递归深度也是O(n)的，一定会栈溢出。

但如果是O(n^2)时间复杂度级别的搜索，递归深度是O(n)就不会溢出

## 递归深度、时间复杂度、8M的联系

!>做一节溢出的思考



## 记忆化搜索题型

[bash游戏](newnotes/leetcode/bash游戏)

[数字三角形](newnotes/leetcode/数字三角形.md)

 [爬楼梯](newnotes/leetcode/爬楼梯.md) 

[爬楼梯II](newnotes/leetcode/爬楼梯II.md)