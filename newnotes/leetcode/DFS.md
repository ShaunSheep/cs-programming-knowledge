# 深度优先搜索

## 前置知识

## 递归基础 

[题目笔记在这里](newnotes/leetcode/递归)

### 二叉树基础

二叉树90%的题目都可以用DFS做

### 概率论基础

dfs的题目中，除了二叉树搜索外，其他题目都属于排列组合类的dfs

概率论的知识用于评估排列类dfs、组合类dfs的时间复杂度

## 概率论知识

[看见统计 - 基础概率论 (需科学上网)](https://seeing-theory.brown.edu/basic-probability/cn.html#section1)

### 阶乘

特殊情况：$0! =1$

### 基本原理[^2]

!>完成一件事的分“类”和“步”是有本质区别的，因此需要将两个原理区分开来。

两个基本原理是排列和组合的基础

(1)**加法原理：**做一件事，完成它可以有n类办法，在第一类办法中有m1种不同的方法，在第二类办法中有$m_2$种不同的方法，……，在第n类办法中有$m_n$种不同的方法，那么完成这件事共有$N=m_1+m_2+m_3+…+m_n$种不同方法。

(2)**乘法原理：**做一件事，完成它需要分成n个步骤，做第一步有$m_1$种不同的方法，做第二步有$m_2$种不同的方法，……，做第n步有$m_n$种不同的方法，那么完成这件事共有$N=m_1×m_2×m_3×…×m_n$种不同的方法。

这里要注意区分两个原理，要做一件事，完成它若是有n类办法，是分类问题，第一类中的方法都是独立的，因此用加法原理；做一件事，需要分n个步骤，步与步之间是连续的，只有将分成的若干个互相联系的步骤，依次相继完成，这件事才算完成，因此用乘法原理。

### 排列

英文名：Arrangement、Permutation ，了解英文名的作用是做题或者函数命名的时候可以借鉴这个名字。

这也是为什么排列使用字母A或者字母P表示。

**排列定义**

从n个`不同元素`中取出m（m≤n）个元素，**按照一定的顺序**排成一列,称做从n个元素中取出m个元素的一个`排列`。

特殊的，m=n时，这个排列被称作`全排列`，$A^n_n=n!$。

又有特殊的，允许重复地选取排列，称为`重复排列`。

从n个不同元素中取出m个不同元素的所有不同排列的个数称为排列种数或称排列数。$A^m_n$或$P^m_n$

排列相等：元素完全相同，且元素的排列顺序也相同，则两个排列相同

**排列公式**：$A^m_n= \frac{n!}{(n-m)!}$，全排列为$A^m_n= n!$，重复排列为$A^m_n= n^m$,特殊的，全排列公式为$A^n_n=n!$

**排列公式推导过程**[^1]：

$A^m_n=n(n-1)(n-2)...(n-m+1)=\frac{n(n-2)...(n-m+1)(n-m)..3\times2\times1}{(n-m)...3\times2\times1}=\frac{n!}{(n-m)!}$

**排列数的通俗解释**——取m个数量的对象，类比成填m个空位，定有排好顺序的m个空位,从n个不同元素a1,a2,a3,…,an中任意取m个去填空,一个空位填1个元素，每一种填法就对应1个排列，因此，所有不同填法的种数就是排列数。

![img](http://cdn.yangchaofan.cn/typora/9e3df8dcd100baa16fa4618c4810b912c8fc2e78)

填空可分为m个步骤：

第1步，第1位可以从n个元素中任选一个填上，共有n种填法；

第2步，第2位只能从余下的n-1个元素中任选一个填上，共有n-1种填法；

第3步，第3位只能从余下的n-2个元素中任选一个填上，共有n-2种填法；

第m步，当前面的m-1个空位都填上后，第m位只能从余下的n-(m-1)个元素中任选一个填上，共有n-m+1种填法。

根据分步计数原理，全部填满m个空位共有n(n-1)(n-2)…(n-m+1)种填法。

所以得到公式：$A^m_n=n(n-1)(n-2)...(n-m+1)$，当n=m时，$A^n_n=n(n-1)(n-2)...1=n!$



### 组合

英文名：Combination，了解英文名的作用同上。

这也是为什么组合使用字母C表示。

从n个不同元素中每次取出m个不同元素（0≤m≤n），**不管其顺序合成一组**，称为从n个元素中不重复地选取m个元素的一个组合。所有这样的组合的总数称为组合数。

**组合公式**：$C^m_n=\frac{n!}{(n-m)!m!}$

**组合的特殊性质**：

- $C^0_1=1$

- $c(n,0)+c(n,1)+c(n,2)+……+c(n,n)=2^n$,这句话的意思是,任何集合的子集个数都为$2^n$个

### 组合与排列的关系？

从n中取m个元素，结果集为组合数$C^m_n$个，排列数$A^m_n$个

- $C^m_n=A^m_n/m!$
- 取出m个元素组成的一组数，取法可以有m!种不同的排列。
  - m个数中取m个数，这属于全排列的定义
  - 全排列公式为$A^n_n=n!$
  - 所以m个数取m个数有m!种排列
- 组合的总数就是组合数公式



# 排列类DFS

## 排列的时间复杂度

排列类dfs时间复杂度$O(N!*n)$,每个方案的构造时间是n

排列的方案个数是$n！$

## DFS时间复杂度通用公式

`O(方案总数 * 构造每个方案的时间)`


## 排列类dfs的实现

1. 多重循环实现
2. 递归实现

?> 递归与循环实现的区别

- 递归实现搜索的本质 是实现了按照给定参数来决定循环层数 的一个多重循环 

- 递归实现的搜索=n重循环，n由输入决定

## 常见题目

### 全排列

[题目笔记在这里](newnotes/leetcode/全排列)

### 字符串置换

[题目笔记在这里](newnotes/leetcode/字符串置换)

### 典型NP问题：TSP旅行商线路问题

题目笔记在这里[TSP旅行商线路问题](newnotes/leetcode/TSP中国旅行社问题)

5种思路：

1. 暴力 DFS 
2. 暴力 DFS + 最优性剪枝(prunning) 
3. 状态压缩动态规划 
4. 随机化算法 - 使用交换调整策略
5. 随机化算法 - 使用反转调整策略 

一个题掌握四种算法：

1. 排列式搜索 Permutaition Style DFS 
2. 最优性剪枝算法 Optimal Prunning Algorithm 
3. 状态压缩动态规划 State Compression Dynamic Programming 
4. 随机化算法 Randomlization Algorithm a. 又称为遗传算法 Genetic Algorithm，模拟退火算法 Simulated Annealing

## 随机化算法

随机化一个初始方案 ，通过一个调整策略调整到局部最优值 ，在时间限制内重复上述过程直到快要超时。

# 组合类DFS

## 组合的时间复杂度

组合类dfs时间复杂度为`O(方案总数 * 构造每个方案的时间)`

一般为$O(2^n)$或$O(n\times C^k_n)$或$O(2^n\times n)$,n是是每个方案的时间,方案个数是2^n

组合的方案个数是$2^n$，每一个方案的个数是n



### 组合类两类画法代码实现有何不同？



## 组合类DFS常见题目类型

常见的都是求组子集的问题，子集问题可以转化为两类问题：

!>这两类引申出两种搜索树的画法，参考[子集问题的两种树画法](#子集问题的两种树画法)



## 组合类DFS常见题目

组合类DFS的题目分为普通版、升级版，高级升级版

- 普通版是[子集](newnotes/leetcode/子集)

- 升级版是[数字组合](newnotes/leetcode/数字组合)，子集没有要求目标和，而数字组合题目要求了目标和

- 高阶升级版是[k数和](newnotes/leetcode/k数和II)，题目k数和要求了数字的个数，而当前题目数字组合不要求数字的个数。

这三类题的关系是

1. 子集属于数字组合
2. 数字组合属于k数和II
3. 子集、数字组合、k数和II属于组合DFS

### 子集

题目笔记再[这里](newnotes/leetcode/子集.md)

### 子集II

题目笔记再[这里](newnotes/leetcode/子集II.md)

### 数字组合

[数字组合](newnotes/leetcode/数字组合)

### K数和

[k数和](newnotes/leetcode/k数和II)

# 组合类DFS与排列类DFS的区别

组合DFS类问题，必须保证按数组顺序访问元素，且一个元素只访问一次，所以需要index来去重，记录当前访问的位置

排列DFS类问题，不需要按顺序访问，只需要保证一个元素访问一次，所以需要visited数组来记录是否访问过，记录已经访问过的节点

？>公式上的区别[参考组合与排列的关系](#组合与排列的关系？)<br>

语义上的区别排列是有顺序的，组合是无顺序的

| 特征       | 组合DFS                  | 排列DFS                   |
| ---------- | ------------------------ | ------------------------- |
| 问题模型   | 求出所有满足条件的组合   | 求出所有满足条件的排列    |
| 判断条件   | 组合中的元素是顺序无关的 | 排列中 的元素是顺序相关的 |
| 时间复杂度 | 与2^n有关系              | 有n!有关系                |



# DFS

?>排列组合问题又可以称为NP问题（非多项式问题）

## 使用条件
- 题干中出现:找满足某个条件的所有方案（99%)
- 题干是二又树BinaryTree的问题（90%)
- 组合问题（95%)
    问题模型：求出所有满足条件的“组合”
    判断条件：组合中的元素是顺序无关的
- 排列问题（95%)
    问题模型：求出所有满足条件的“排列”
    判断条件：组合中的元素是顺序“相关”的。

## 注意事项

- 显式搜索树是直接在一个明显的二叉树上搜索
- 隐式搜索树设计需要自己动脑思考树的构成
- 需要构造一颗搜索树或者一个图
- 需要自己定义点、边、路径，自己编写递归函数，最难的是定义路径
- 搜索去重的方法是--在重复方案中选代表
- 搜索去重的错误方法是--把所有方案放在hashset里去重

## 两种搜索树画法

### 概览

两个树都可以用bfs和dfs搜索

![mark](http://cdn.yangchaofan.cn/BlogGifRes/20210627/x1z5ytRnOx7T.png?imageslim)

复杂度

- 树2
  - 时间：进行bfs、dfs的时间复杂度都是2^n
  - 空间，d.fs是递归的耗费需要logn；bfs是宽度的最大值2^n ， n是节点个数
  - 因此，一般使用dfs做排列组合的问题，是为了解决内存耗费过大的问题

**树结构不同**

- 树1是多叉树 ,适合排列类、组合类问题
- 树2是二叉树，仅适合组合类问题，如子集问题

**找的目标不同**

- 树1？？？、
- 树2只适用于全子集的问题，无法运用于全排列的问题

**答案不同**

- 树1的答案，在于所有的节点总和
- 树2的答案，在于叶节点总和

**特性不同**

- 树1特性
  - 取n次，每次问还剩下哪些点可放

- 树2特性
  - 取n次，第一次问是否放第一个点，第二次是否放第二个点，第n次问是否放第n个点

**进行bfs与dfs两种搜索方式有区别**

- 时间复杂度不同，bfs取决于宽度$O(n)$，dfs取决于深度$O(n)$
- 空间复杂度,dfs是取决于深度即$O(n)$，bfs是取决于宽度即$O(2^n)$

### 第一类第i轮从剩余数中取谁

- 开始，取空
- 第1轮，从n个数取1个，有n种取法
- 第2轮，从n-1个数取n-1，有n-1中取法
- 第n轮，从1个数取1个，有1种取法

![mark](http://cdn.yangchaofan.cn/BlogGifRes/20210626/fTXTJLJ6KnTT.jpg?imageslim)

从网上找了一个更好看的图解[78.子集，回溯法详解，python实现 - 子集 ](https://leetcode-cn.com/problems/subsets/solution/78zi-ji-hui-su-fa-xiang-jie-pythonshi-xi-2aul/)，跟我手绘的类似

![](https://pic.leetcode-cn.com/1621565060-EECCPd-1.png)

### 第二类每个位置的元素取或不取

集合中有n个不重复数，按顺序从集合中访问，取n个数取或者不取得问题，如图

- 访问第一个位置的元素，取不取它？若取，则结果集写1，若不取，则及结果集写空
- 访问第二个位置，取不取它？若取，则结果集追加第二个位置的元素，即[1，2]或[2]，若不取，则如图
- ....
- 访问第n个位置，取不取它？若取，则更新结果集，若不取，也更新结果集。
- 最后一轮取完，问题的解是所有的结果集

![mark](http://cdn.yangchaofan.cn/BlogGifRes/20210626/fcUp7BugWG04.jpg?imageslim)

## 隐式搜索树的建模

想做好建模，需要理解图与搜索树的关系；

想理解搜索树的画法，需要理解xxx

### 找到某个条件的方案

找到图中所有满足条件的**路径**

图是如何构成的？

- 谁是节点
- 谁是路径
- 节点的排列
- 节点的组合

路径是如何构成的？

- 路径的数量与方案的数量的关系

### 子集问题

![子集问题-隐式搜索树构造](http://cdn.yangchaofan.cn/typora/子集问题-隐式搜索树构造.png)

上图的解释

- 点：每个数是一个点，集合中的每一个元素构成了途中的一个点
- 边：元素与元素之间用有向边连接。为了达到**去重**的目标，我们需要通过代码手段约束，强制让小的点指向大的店，保持一定得有序性。
- 路径：路径的数量就是子集的数量；每一条路径就是一个子集；路径是指任意一个节点出发，到达任意一点结束的一条路径，即路径长度是不定的

!>子集问题的**去重操作**如何做？

1.选代表

2.保证图中走过的路径节点是从小到大的

- 这就需要我们通过代码对数组元素排序

### 全排列问题

- 点：每个数是一个点
- 边：任意两个点之间都有连边，而且边没有方向
- 路径：即排列 ，即从任一点除法到任一点结束，**经过的每个点（仅经过一次）**所连接成的路径
  - 一个排列就是一条路径，一个排列由多个点构成
  - 我们要找的是所有的排列


## 不要用DFS的场景

1. 连通块问题（一定要用BFS，否则Stackoverflow)
2. 拓扑排序（一定要用BFS，否则Stackoverflow)
3. 一切BFS可以解决的问题，就优先用BFS做，不要用DFS做

## 复杂度
时间复杂度：`O（方案个数”构造每个方案的时间）`
- 树的遍历：$O(n)$
- 排列问题：$0(n!*n)$
- 组合问题：$O(2^n*n)$

## 递归树模板

![DFS题型-回溯-return的时机-递归三要素](http://cdn.yangchaofan.cn/typora/DFS题型-回溯-return的时机-递归三要素.svg)

dfs是在每一次return 的时候更新答案：增加一份符合条件的子答案

## dfs递归代码模板

```java
public ReturnType dfs(参数列表) {
    if (递归出口) {
        记录答案;
        return;
    }
    for (所有的拆解可能性) {
       修改所有的参数
        dfs(参数列表);
        还原所有被修改过的参数
     }
     return something 如果需要的话，很多时候不需要 return 值除了分治的写法
 }
```

## DFS常见题目

### 子集类问题

常见有3类明显的子集问题、数字组合、k数和,直接用dfs模板做小变化即可

#### 明显子集

题目笔记在这

  [子集 II](newnotes/leetcode/子集II.md)

  [子集](newnotes/leetcode/子集.md)

#### 数字组合类问题

[数字组合](newnotes/leetcode/数字组合.md)

#### K数和类问题

 [k数和（二）](newnotes/leetcode/k数和II.md)

### 排列问题

题目笔记在这

[全排列](newnotes/leetcode/全排列.md)

### 字符串置换

题目笔记在这

[字符串置换](newnotes/leetcode/字符串置换.md)

### 字符串的不同排列

题目笔记在这

[字符串的不同排列](newnotes/leetcode/字符串的不同排列.md)



# 参考

[^1]:[排列数公式推导过程_百度百科 (baidu.com)](https://baike.baidu.com/item/排列数公式/8532609?fr=aladdin#2_3)
[^2]:[排列组合的基本原理_百度百科 (baidu.com)](https://baike.baidu.com/item/排列数公式/8532609?fr=aladdin#3)

