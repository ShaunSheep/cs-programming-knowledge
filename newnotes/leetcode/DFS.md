# 深度优先搜索

## 前置知识

## 概率论知识

[看见统计 - 基础概率论 (需科学上网)](https://seeing-theory.brown.edu/basic-probability/cn.html#section1)

### 阶乘

特殊情况：$0! =1$

### 基本原理[^2]

!>完成一件事的分“类”和“步”是有本质区别的，因此需要将两个原理区分开来。

两个基本原理是排列和组合的基础

(1)**加法原理：**做一件事，完成它可以有n类办法，在第一类办法中有m1种不同的方法，在第二类办法中有$m_2$种不同的方法，……，在第n类办法中有$m_n$种不同的方法，那么完成这件事共有$N=m_1+m_2+m_3+…+m_n$种不同方法。

(2)**乘法原理：**做一件事，完成它需要分成n个步骤，做第一步有$m_1$种不同的方法，做第二步有$m_2$种不同的方法，……，做第n步有$m_n$种不同的方法，那么完成这件事共有$N=m_1×m_2×m_3×…×m_n$种不同的方法。

这里要注意区分两个原理，要做一件事，完成它若是有n类办法，是分类问题，第一类中的方法都是独立的，因此用加法原理；做一件事，需要分n个步骤，步与步之间是连续的，只有将分成的若干个互相联系的步骤，依次相继完成，这件事才算完成，因此用乘法原理。

### 排列

英文名：Arrangement、Permutation ，了解英文名的作用是做题或者函数命名的时候可以借鉴这个名字。

这也是为什么排列使用字母A或者字母P表示。

**排列定义**

从n个`不同元素`中取出m（m≤n）个元素，**按照一定的顺序**排成一列,称做从n个元素中取出m个元素的一个`排列`。

特殊的，m=n时，这个排列被称作`全排列`，$A^n_n=n!$。

又有特殊的，允许重复地选取排列，称为`重复排列`。

从n个不同元素中取出m个不同元素的所有不同排列的个数称为排列种数或称排列数。$A^m_n$或$P^m_n$

排列相等：元素完全相同，且元素的排列顺序也相同，则两个排列相同

**排列公式**：$A^m_n= \frac{n!}{(n-m)!}$，全排列为$A^m_n= n!$，重复排列为$A^m_n= n^m$,特殊的，全排列公式为$A^n_n=n!$

**排列公式推导过程**[^1]：

$A^m_n=n(n-1)(n-2)...(n-m+1)=\frac{n(n-2)...(n-m+1)(n-m)..3\times2\times1}{(n-m)...3\times2\times1}=\frac{n!}{(n-m)!}$

**排列数的通俗解释**——取m个数量的对象，类比成填m个空位，定有排好顺序的m个空位,从n个不同元素a1,a2,a3,…,an中任意取m个去填空,一个空位填1个元素，每一种填法就对应1个排列，因此，所有不同填法的种数就是排列数。

![img](http://cdn.yangchaofan.cn/typora/9e3df8dcd100baa16fa4618c4810b912c8fc2e78)

填空可分为m个步骤：

第1步，第1位可以从n个元素中任选一个填上，共有n种填法；

第2步，第2位只能从余下的n-1个元素中任选一个填上，共有n-1种填法；

第3步，第3位只能从余下的n-2个元素中任选一个填上，共有n-2种填法；

第m步，当前面的m-1个空位都填上后，第m位只能从余下的n-(m-1)个元素中任选一个填上，共有n-m+1种填法。

根据分步计数原理，全部填满m个空位共有n(n-1)(n-2)…(n-m+1)种填法。

所以得到公式：$A^m_n=n(n-1)(n-2)...(n-m+1)$，当n=m时，$A^n_n=n(n-1)(n-2)...1=n!$



### 组合

英文名：Combination，了解英文名的作用同上。

这也是为什么组合使用字母C表示。

从n个不同元素中每次取出m个不同元素（0≤m≤n），**不管其顺序合成一组**，称为从n个元素中不重复地选取m个元素的一个组合。所有这样的组合的总数称为组合数。

**组合公式**：$C^m_n=\frac{n!}{(n-m)!m!}$

**组合的特殊性质**：

- $C^0_1=1$

- $c(n,0)+c(n,1)+c(n,2)+……+c(n,n)=2^n$,这句话的意思是,任何集合的子集个数都为$2^n$个

### 组合与排列的关系？

从n中取m个元素，结果集为组合数$C^m_n$个，排列数$A^m_n$个

- $C^m_n=A^m_n/m!$
- 取出m个元素组成的一组数，取法可以有m!种不同的排列。
  - m个数中取m个数，这属于全排列的定义
  - 全排列公式为$A^n_n=n!$
  - 所以m个数取m个数有m!种排列
- 组合的总数就是组合数公式



# 排列类DFS

## 排列的时间复杂度

排列类dfs时间复杂度$O(N!*n)$

## 第一个问题：组合类于排列类的区别

公式上的区别[参考组合与排列的关系](#组合与排列的关系？)

语义上的区别排列是有顺序的，组合是无顺序的

## 第二个问题：DFS时间复杂度通用公式

`O(方案总数 * 构造每个方案的时间)`


## 排列类dfs的实现

1. 多重循环实现
2. 递归实现

?> 递归与循环实现的区别

- 递归实现搜索的本质 是实现了按照给定参数来决定循环层数 的一个多重循环 

- 递归实现的搜索=n重循环，n由输入决定

## 常见题目

### 全排列

题目笔记在[这里](newnotes/leetcode/全排列.md)

### 典型NP问题：TSP旅行商线路问题

题目笔记在这里[TSP旅行商线路问题](newnotes/leetcode/TSP中国旅行社问题.md)

5种思路：

1. 暴力 DFS 
2. 暴力 DFS + 最优性剪枝(prunning) 
3. 状态压缩动态规划 
4. 随机化算法 - 使用交换调整策略
5. 随机化算法 - 使用反转调整策略 

一个题掌握四种算法：

1. 排列式搜索 Permutaition Style DFS 
2. 最优性剪枝算法 Optimal Prunning Algorithm 
3. 状态压缩动态规划 State Compression Dynamic Programming 
4. 随机化算法 Randomlization Algorithm a. 又称为遗传算法 Genetic Algorithm，模拟退火算法 Simulated Annealing

## 随机化算法

随机化一个初始方案 ，通过一个调整策略调整到局部最优值 ，在时间限制内重复上述过程直到快要超时。

# 组合类DFS

组合类dfs时间复杂度$O(2^n)$---答案是否正确，存疑

## 两种搜索树画法

两个树都可以用bfs和dfs搜索，适用于子集类问题、组合类问题

![mark](http://cdn.yangchaofan.cn/BlogGifRes/20210627/x1z5ytRnOx7T.png?imageslim)

**答案不同**

- 树1的答案，在于所有的节点总和
- 树2的答案，在于叶节点总和

**特性不同**

- 树1特性
  - 取n次，每次问还剩下哪些点可放

- 树2特性
  - 取n次，第一次问是否放第一个点，第二次是否放第二个点，第n次问是否放第n个点

**进行bfs与dfs两种搜索方式有区别**

- 时间复杂度不同，bfs取决于宽度O(n)，dfs取决于深度O(n)
- 空间复杂度,dfs是取决于深度即$O(n)$，bfs是取决于宽度即$O(2^n)$

### 第一类第i轮从剩余数中取谁

- 开始，取空
- 第1轮，从n个数取1个，有n种取法
- 第2轮，从n-1个数取n-1，有n-1中取法
- 第n轮，从1个数取1个，有1种取法

![mark](http://cdn.yangchaofan.cn/BlogGifRes/20210626/fTXTJLJ6KnTT.jpg?imageslim)

从网上找了一个更好看的图解[78.子集，回溯法详解，python实现 - 子集 ](https://leetcode-cn.com/problems/subsets/solution/78zi-ji-hui-su-fa-xiang-jie-pythonshi-xi-2aul/)，跟我手绘的类似

![](https://pic.leetcode-cn.com/1621565060-EECCPd-1.png)

## 第二类每个位置的元素取或不取

集合中有n个不重复数，按顺序从集合中访问，取n个数取或者不取得问题，如图

- 访问第一个位置的元素，取不取它？若取，则结果集写1，若不取，则及结果集写空
- 访问第二个位置，取不取它？若取，则结果集追加第二个位置的元素，即[1，2]或[2]，若不取，则如图
- ....
- 访问第n个位置，取不取它？若取，则更新结果集，若不取，也更新结果集。
- 最后一轮取完，问题的解是所有的结果集

![mark](http://cdn.yangchaofan.cn/BlogGifRes/20210626/fcUp7BugWG04.jpg?imageslim)

## 常见题目类型

常见的都是求组子集的问题，子集问题可以转化为两类问题：

!>这两类引申出两种搜索树的画法，参考[子集问题的两种树画法](#子集问题的两种树画法)





## 组合类DFS常见题目

### 子集

题目笔记再[这里](newnotes/leetcode/子集.md)

### 子集II

题目笔记再[这里](newnotes/leetcode/子集II.md)



# DFS
## 使用条件
- 找满足某个条件的所有方案（99%)
- 二又树BinaryTree的问题（90%)
- 组合问题（95%)
    问题模型：求出所有满足条件的“组合”
    判断条件：组合中的元素是顺序无关的
- 排列问题（95%)
    问题模型：求出所有满足条件的“排列”
    判断条件：组合中的元素是顺序“相关”的。

## 注意事项

- 需要构造一颗搜索树或者一个图
- 需要自己定义点、边、路径，自己编写递归函数，最难的是定义路径
- 搜索去重的方法是--在重复方案中选代表
- 搜索去重的错误方法是--把所有方案放在hashset里去重

## DFS构造搜索树举例

### 全排列问题

- 点：每个数是一个点
- 边：任意两个点之间都有连边，而且边没有方向
- 路径：即排列 ，即从任一点除法到任一点结束，经过的每个点（仅经过一次）所连接成的路径
  - 一个排列就是一条路径，一个排列由多个点构成
  - 我们要找的是所有的排列

- 

## 不要用DFS的场景

1. 连通块问题（一定要用BFS，否则Stackoverflow)
2. 拓扑排序（一定要用BFS，否则Stackoverflow)
3. 一切BFS可以解决的问题

## 复杂度
时间复杂度：`O（方案个数”构造每个方案的时间）`
- 树的遍历：$O(n)$
- 排列问题：$0(n!*n)$
- 组合问题：$O(2^n*n)$

## 代码模板

```java
public ReturnType dfs(参数列表) {
    if (递归出口) {
        记录答案;
        return;
    }
    for (所有的拆解可能性) {
       修改所有的参数
        dfs(参数列表);
        还原所有被修改过的参数
     }
     return something 如果需要的话，很多时候不需要 return 值除了分治的写法
 }
```

## DFS常见题目

### 子集类问题

常见有3类明显的子集问题、数字组合、k数和,直接用dfs模板做小变化即可

#### 明显子集

题目笔记在这

  [子集 II](newnotes/leetcode/子集II.md)

  [子集](newnotes/leetcode/子集.md)

#### 数字组合类问题

[数字组合](newnotes/leetcode/数字组合.md)

#### K数和类问题

 [k数和（二）](newnotes/leetcode/k数和II.md)

### 排列问题

题目笔记在这

[全排列](newnotes/leetcode/全排列.md)

### 字符串置换

题目笔记在这

[字符串置换](newnotes/leetcode/字符串置换.md)

### 字符串的不同排列

题目笔记在这

[字符串的不同排列](newnotes/leetcode/字符串的不同排列.md)



# 参考

[^1]:[排列数公式推导过程_百度百科 (baidu.com)](https://baike.baidu.com/item/排列数公式/8532609?fr=aladdin#2_3)
[^2]:[排列组合的基本原理_百度百科 (baidu.com)](https://baike.baidu.com/item/排列数公式/8532609?fr=aladdin#3)

