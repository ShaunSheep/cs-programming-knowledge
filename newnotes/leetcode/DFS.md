# 深度优先搜索

# 组合类DFS

排列类dfs时间复杂度$O(2^n)$---答案是否正确，存疑

从n个不同元素中每次取出m个不同元素（0≤m≤n），**不管其顺序合成一组**，称为从n个元素中不重复地选取m个元素的一个组合。所有这样的组合的总数称为组合数。

# 排列类DFS

## 排列的定义

从n个`不同元素`中取出m（m≤n）个元素，**按照一定的顺序**排成一列,称做从n个元素中取出m个元素的一个`排列`。

特殊的，m=n时，这个排列被称作`全排列`。

又有特殊的，允许重复地选取排列，称为`重复排列`。

从n个不同元素中取出m个不同元素的所有不同排列的个数称为排列种数或称排列数。$A^m_n$或$P^m_n$

排列相等：元素完全相同，且元素的排列顺序也相同，则两个排列相同

排列公式：$A^m_n= \frac{n!}{(n-m)!}$，全排列为$A^m_n= n!$，重复排列为$A^m_n= n^m$

## 排列的时间复杂度

排列类dfs时间复杂度$O(N!*n)$

## 第一个问题：组合类于排列类的区别

## 第二个问题：DFS时间复杂度通用公式

`O(方案总数 * 构造每个方案的时间)`

## 排列类dfs的实现

1. 多重循环实现
2. 递归实现

?> 递归与循环实现的区别

- 递归实现搜索的本质 是实现了按照给定参数来决定循环层数 的一个多重循环 

- 递归实现的搜索=n重循环，n由输入决定

## 典型NP问题：TSP中国邮政线路问题

5种思路：

1. 暴力 DFS 
2. 暴力 DFS + 最优性剪枝(prunning) 
3. 状态压缩动态规划 
4. 随机化算法 - 使用交换调整策略
5.  随机化算法 - 使用反转调整策略 

一个题掌握四种算法：

1. 排列式搜索 Permutaition Style DFS 
2. 最优性剪枝算法 Optimal Prunning Algorithm 
3. 状态压缩动态规划 State Compression Dynamic Programming 
4. 随机化算法 Randomlization Algorithm a. 又称为遗传算法 Genetic Algorithm，模拟退火算法 Simulated Annealing

## 随机化算法

随机化一个初始方案 ，通过一个调整策略调整到局部最优值 ，在时间限制内重复上述过程直到快要超时。

# DFS
## 使用条件
- 找满足某个条件的所有方案（99%)
- 二又树BinaryTree的问题（90%)
- 组合问题（95%)
    问题模型：求出所有满足条件的“组合”
    判断条件：组合中的元素是顺序无关的
- 排列问题（95%)
    问题模型：求出所有满足条件的“排列”
    判断条件：组合中的元素是顺序“相关”的。

## 不要用DFS的场景
1. 连通块问题（一定要用BFS，否则Stackoverflow)
2. 拓扑排序（一定要用BFS，否则Stackoverflow)
3. 一切BFS可以解决的问题

## 复杂度
时间复杂度：`O（方案个数”构造每个方案的时间）`
- 树的遍历：$O(n)$
- 排列问题：$0(n!*n)$
- 组合问题：$O(2^n*n)$

## 代码模板

```java
public ReturnType dfs(参数列表) {
    if (递归出口) {
        记录答案;
        return;
    }
    for (所有的拆解可能性) {
       修改所有的参数
        dfs(参数列表);
        还原所有被修改过的参数
     }
     return something 如果需要的话，很多时候不需要 return 值除了分治的写法
 }
```

