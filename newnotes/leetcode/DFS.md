# 深度优先搜索

# 组合类DFS

组合类dfs时间复杂度$O(2^n)$---答案是否正确，存疑

从n个不同元素中每次取出m个不同元素（0≤m≤n），**不管其顺序合成一组**，称为从n个元素中不重复地选取m个元素的一个组合。所有这样的组合的总数称为组合数。

## 常见题型

?>常见的都是求组子集的问题

子集问题可以转化为一组数取或者不取得问题，如图

![mark](http://cdn.yangchaofan.cn/BlogGifRes/20210626/fcUp7BugWG04.jpg?imageslim)

搜索树的递归过程如下：

![mark](http://cdn.yangchaofan.cn/BlogGifRes/20210626/fTXTJLJ6KnTT.jpg?imageslim)

## 子集

题目笔记再[这里](newnotes/leetcode/子集.md)

### 子集II

题目笔记再[这里](newnotes/leetcode/子集II.md)

# 排列类DFS

## 排列的定义

从n个`不同元素`中取出m（m≤n）个元素，**按照一定的顺序**排成一列,称做从n个元素中取出m个元素的一个`排列`。

特殊的，m=n时，这个排列被称作`全排列`。

又有特殊的，允许重复地选取排列，称为`重复排列`。

从n个不同元素中取出m个不同元素的所有不同排列的个数称为排列种数或称排列数。$A^m_n$或$P^m_n$

排列相等：元素完全相同，且元素的排列顺序也相同，则两个排列相同

排列公式：$A^m_n= \frac{n!}{(n-m)!}$，全排列为$A^m_n= n!$，重复排列为$A^m_n= n^m$

## 排列的时间复杂度

排列类dfs时间复杂度$O(N!*n)$

## 第一个问题：组合类于排列类的区别

## 第二个问题：DFS时间复杂度通用公式

`O(方案总数 * 构造每个方案的时间)`


## 排列类dfs的实现

1. 多重循环实现
2. 递归实现

?> 递归与循环实现的区别

- 递归实现搜索的本质 是实现了按照给定参数来决定循环层数 的一个多重循环 

- 递归实现的搜索=n重循环，n由输入决定

## 常见题型

### 全排列

题目笔记在[这里](newnotes/leetcode/全排列.md)

### 典型NP问题：TSP旅行商线路问题

题目笔记在这里[TSP旅行商线路问题](newnotes/leetcode/TSP中国旅行社问题.md)

5种思路：

1. 暴力 DFS 
2. 暴力 DFS + 最优性剪枝(prunning) 
3. 状态压缩动态规划 
4. 随机化算法 - 使用交换调整策略
5.  随机化算法 - 使用反转调整策略 

一个题掌握四种算法：

1. 排列式搜索 Permutaition Style DFS 
2. 最优性剪枝算法 Optimal Prunning Algorithm 
3. 状态压缩动态规划 State Compression Dynamic Programming 
4. 随机化算法 Randomlization Algorithm a. 又称为遗传算法 Genetic Algorithm，模拟退火算法 Simulated Annealing

## 随机化算法

随机化一个初始方案 ，通过一个调整策略调整到局部最优值 ，在时间限制内重复上述过程直到快要超时。

# DFS
## 使用条件
- 找满足某个条件的所有方案（99%)
- 二又树BinaryTree的问题（90%)
- 组合问题（95%)
    问题模型：求出所有满足条件的“组合”
    判断条件：组合中的元素是顺序无关的
- 排列问题（95%)
    问题模型：求出所有满足条件的“排列”
    判断条件：组合中的元素是顺序“相关”的。

## 注意事项

- 需要构造一颗搜索树或者一个图
- 需要自己定义点、边、路径，自己编写递归函数，最难的是定义路径
- 搜索去重的方法是--在重复方案中选代表
- 搜索去重的错误方法是--把所有方案放在hashset里去重

## DFS构造搜索树举例

### 全排列问题

- 点：每个数是一个点
- 边：任意两个点之间都有连边，而且边没有方向
- 路径：即排列 ，即从任一点除法到任一点结束，经过的每个点（仅经过一次）所连接成的路径
  - 一个排列就是一条路径，一个排列由多个点构成
  - 我们要找的是所有的排列

### 子集问题的两种树画法

两个树都可以用bfs和dfs搜索

![mark](http://cdn.yangchaofan.cn/BlogGifRes/20210627/x1z5ytRnOx7T.png?imageslim)

树1特性

- 取n次，每次问还剩下哪些点可放

树2特性

- 取n次，第一次问是否放第一个点，第二次是否放第二个点，第n次问是否放第n个点

二叉搜索树上，进行bfs与dfs两种搜索方式，有区别

- 时间复杂度不同，bfs取决于宽度O(n)，dfs取决于深度O(n)
- 空间复杂度,dfs是取决于深度即$O(n)$，bfs是取决于宽度即$O(2^n)$

## 不要用DFS的场景

1. 连通块问题（一定要用BFS，否则Stackoverflow)
2. 拓扑排序（一定要用BFS，否则Stackoverflow)
3. 一切BFS可以解决的问题

## 复杂度
时间复杂度：`O（方案个数”构造每个方案的时间）`
- 树的遍历：$O(n)$
- 排列问题：$0(n!*n)$
- 组合问题：$O(2^n*n)$

## 代码模板

```java
public ReturnType dfs(参数列表) {
    if (递归出口) {
        记录答案;
        return;
    }
    for (所有的拆解可能性) {
       修改所有的参数
        dfs(参数列表);
        还原所有被修改过的参数
     }
     return something 如果需要的话，很多时候不需要 return 值除了分治的写法
 }
```

## 常见题目

### 子集类问题

常见有3类明显的子集问题、数字组合、k数和,直接用dfs模板做小变化即可

#### 明显子集

题目笔记在这

  [子集 II](newnotes/leetcode/子集II.md)

  [子集](newnotes/leetcode/子集.md)

#### 数字组合类问题

[数字组合](newnotes/leetcode/数字组合.md)

#### K数和类问题

 [k数和（二）](newnotes/leetcode/k数和II.md)

### 排列问题

题目笔记在这

[全排列](newnotes/leetcode/全排列.md)

### 字符串置换

题目笔记在这

[字符串置换](newnotes/leetcode/字符串置换.md)

### 字符串的不同排列

题目笔记在这

[字符串的不同排列](newnotes/leetcode/字符串的不同排列.md)
